<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
	<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<title>

하드링크 오용 탐지 방법 • Diffense

</title>
<meta name="description" content="하드링크란 무엇이며, 취약점을 악용하는데 하드링크는 어떻게 활용되는지 살펴본다. ">
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/feed.xml">

<!-- icons -->
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
<meta name="theme-color" content="#00f0ff">
<meta name="msapplication-TileColor" content="#00f0ff">
<meta name="msapplication-TileImage" content="/mstile-310x310.png">
<!-- /icons -->

<!-- og tags -->
<meta property="og:site_name" content="Diffense">
<meta property="og:title" content="하드링크 오용 탐지 방법 • Diffense">
<meta property="og:locale" content="en">

  
    <meta property="og:image" content="http://localhost:4000/img/og-image.jpg">
  

<meta property="og:type" content="website">
<meta property="og:url" content="http://localhost:4000/2019/02/22/hard-link/">
<meta property="og:description" content="

하드링크란 무엇이며, 취약점을 악용하는데 하드링크는 어떻게 활용되는지 살펴본다.
">
<!-- /og tags -->

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="/js/modernizr.js"></script>
<script src="/js/fitvids.js"></script>
<link href='//fonts.googleapis.com/css?family=Source+Code+Pro:400,700|Source+Sans+Pro:600,900|Crimson+Text:700italic,600,600italic,400,700,400italic' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/css/reset.css">
<link rel="stylesheet" href="/css/pygments.css">

<link rel="stylesheet" href="/css/style.css">
<!--[if gte IE 9]>
  <style type="text/css">
    .gradient {
       filter: none;
    }
  </style>
<![endif]-->


<style>
header {
  margin-bottom: 40px;
}
@media all and (min-width: 500px) {
  header {
    margin-bottom: 100px;
  }
}
header::after {
  display: none;
}
</style>


</head>
<body>
	
	<div class="wrap">
		<header>
  <a href="/" class="website-title">
    
      Diffense
    

  </a>
  <nav>
  <a href="/about/">About</a>
  <a href="/contact/">Contact</a>
  <a href="/archive/">Archive</a>
</nav>

  
</header>

		


<article>
  <span class="meta">Feb 22, 2019 • 3&nbsp;min read</span>
	<h1>하드링크 오용 탐지 방법</h1>
		<h4 id="들어가기에-앞서">들어가기에 앞서</h4>

<p>다음 자료를 참고하였습니다.</p>

<ul>
  <li>James forshaw</li>
  <li>MSDN</li>
</ul>

<h4 id="하드링크">하드링크?</h4>

<p>하드링크는 파일간 연결시켜주는 방법입니다.
심볼릭링크와 차이점이 있습니다.</p>

<p>하드링크는 다음과 같은 제약을 가집니다.</p>

<ul>
  <li>디렉토리간에는 하드링크를 만들 수 없습니다.</li>
  <li>다른 볼륨간에 하드링크를 만들 수 없습니다.</li>
</ul>

<h4 id="하드링크-생성-방법">하드링크 생성 방법</h4>

<p>커맨드라인에서 mklink 명령어를 이용하면 하드링크를 만들 수 있습니다.</p>

<p>설명을 위해 먼저 hello.txt를 만들겠습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type hello &gt; hello.txt
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mklink /H hi.txt hello.txt
</code></pre></div></div>

<p>mklink 명령어는 <code class="highlighter-rouge">CreateHardLink</code> API를 이용해서 하드링크를 만듭니다.</p>

<p>다른 프로그램도 하드링크 생성이 필요하면 CreateHardLink를 사용하면 됩니다.</p>

<h4 id="하드링크-오용hardlink-abusing">하드링크 오용(Hardlink abusing)</h4>

<p>James Forshaw는 흥미로운 사실을 발견하게 됩니다.</p>

<p><code class="highlighter-rouge">CreateHardLink</code> API는 내부적으로 <code class="highlighter-rouge">NtOpenFile</code>과 <code class="highlighter-rouge">NtSetInformation</code> 을 호출하여 하드링크 생성을 윈도우즈OS에 요청합니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">CreateHardLinkW</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">NtOpenfile</span>
<span class="p">}</span>
</code></pre></div></div>

<p>여기서 FILE_WRITE_ATTRIBUTE 권한을 요구하는데, 만약 현재사용자(프로세스)가 대상파일에 속성쓰기 권한이 없다면, CreateHardLink API 호출은 실패하게 됩니다.</p>

<p>James Forshaw가 지적한 부분은, NtOpenFile 을 호출할 때 FILE_WRITE_ATTRIBUTE를 요구하지 않아도 NtSetInformation을 통해 하드링크가 생성된다는 사실입니다.</p>

<p>CreateHardlink 를 부르지 않고, 다음과 같이 직접 (usermode) 네이티브 API를 호출하는 방법을 이용하는 것이죠.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NtOpenFile</span><span class="p">(,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">NtSetInformation</span><span class="p">();</span>
</code></pre></div></div>

<p>mklink 는 실패하는데, James forshaw가 만든 createhardlink 툴은 하드링크 생성에 실패하는 것을 보여줍니다.</p>

<h3 id="취약점">취약점</h3>

<p>일반 유저 권한에서 거의 모든 파일(같은 볼륨 내)에 대해서 JF가 언급한 방법을 사용하면 하드링크를 생성할 수 있습니다.</p>

<p>하지만 그게 다입니다. 대상파일에 쓰기가 허용되지 않는다면, 하드링크를 통해서 쓰는 것 역시 허용되지 않습니다. 그럼 취약점이 없는 것 아닙니까? 라고 생각할 수 있을 것입니다.</p>

<p>만약 높은 권한(Admin이나 System권한)으로 돌아가는 서비스프로세스가 있다고 생각해봅시다.</p>

<p>이 서비스프로세스는 (어떤이유에서인지는 몰라도) 특정 디렉토리 위치에 있는 파일의 퍼미션을 바꾸는 작업을 합니다. 해당 파일에 대해 일반 사용자(User 그룹)도 쓰기 권한을 가지도록 퍼미션을 바꾼다고 생각해보자는 거죠.</p>

<p>여기서 만약 일반 사용자가 디렉토리의 파일 생성과 삭제 권한을 가진다면, 권한 상승 취약점으로 발전시킬 수 있습니다. 하드링크를 통해서 말이죠.</p>

<p>시스템프로세스가 파일의 퍼미션을 변경하기 직전에, 일반사용자가 해당 파일을 삭제하는 동시에 동일한 이름의 하드링크(타겟 예: System32\kernel32.dll)를 만들게 되면 어떻게 될까요?</p>

<p>시스템프로세스는 하드링크에 대해 퍼미션 변경작업을 수행하게 될 것이고, 결국 일반 사용자가 쓰기 접근이 불가능했던 파일(에:kernel32.dll)에 대해 쓰기 권한을 획득할 수 있게 됩니다.</p>

<h3 id="cve-">CVE-</h3>

<p>sandboxescaper라는 리서쳐가 제로데이를 공개하면서 많은 이슈를 모았었습니다. 보통은 벤더사에 리포트를 하고, 패치 작업이 이루어진 다음에 관련 내용을 공개하는 것이 일반적인데 sandboxescaper는 fully 동작가능한 수준의 제로데이 코드를 깃허브에 공개하면서 많은 이슈가 되었던 것이죠. 해당 취약점은 비관리자(nonAdmin) 권한에서 관리자(Admin)권한으로 EoP는 취약점입니다.</p>

<p>공개되고 나서, 몇몇 APT 그룹에서 오퍼레이션에 활용했다는 사실이 밝혀지기도 했습니다.</p>

<p>하드링크를 활용하는 좋은(?) 예 중 하나입니다.</p>

<p>취약점은 스케쥴러 서비스에 존재합니다.</p>

<p>스케쥴러 서비스는 ALPC포트라는 일종의 IPC를 통해 일반프로세스도 스케쥴링 서비스를 이용할 수 있도록 외부 인터페이스를 열어두었습니다. 이 중에서 SchedRPC 기능이 있었는데, 해당 기능은 <code class="highlighter-rouge">C:\Windows\Temp</code> 디렉토리에 있는 파일의 퍼미션을 조작할 수 있도록 해줍니다.</p>

<p>해당 Temp디렉토리는 일반유저도 쓰기 가능한 디렉토리입니다.</p>

<p>따라서 앞서 좋은 조건을 갖추고 있습니다.</p>

<ul>
  <li>하드링크를 생성한다.
    <ul>
      <li>C:\Windows\Temp\Test.dll -&gt; C:\Printer\print.dll</li>
    </ul>
  </li>
  <li>스케쥴러 서비스를 호출한다.
    <ul>
      <li>print.dll 의 DACL을 변경합니다. (일반 사용자도 쓰기 가능하도록)</li>
    </ul>
  </li>
  <li>이때부터 print.dll의 내용은 일반유저도 변경할 수 있습니다.
    <ul>
      <li>print.dll에 나쁜(?) 코드를 심어둡니다.</li>
    </ul>
  </li>
  <li>스풀러 프로세스를 호출하여 print.dll 을 물고 올라가도록 합니다.</li>
  <li>스풀러 프로세스 컨텍스트에서 해당 코드가 실행되며 권한상승이 이루어집니다.</li>
</ul>

<p>###</p>

<p>특히 파일의 퍼미션을 수정해야 할 필요성이 있는 안티바이러스나 업데이트 프로그램 등에서 해당 유형의 취약점이 있을 가능성이 높습니다.</p>

<h3 id="대처-방안">대처 방안</h3>

<p>앞서 언급한 하드링크를 통한 권한상승 취약점 유형은 언제든지 발견될 수 있습니다.</p>

<p>취약점 대처 방안으로 익스플로잇이 발견될 때마다 그것에 맞춰 대응하는 방법(패턴매칭)이 대부분의 AV업체 등에서</p>

<p>이러한 방법은 제로데이 익스플로잇에 대해서는 탐지율이 낮다는 단점이 있습니다.</p>

<p>저희 디펜스에서 출시 예정인 X-DIFFENSE에서는 하드링크를 오용하기 위해선 일반적인 CreateHardLink를 이용하는 것이 아니라, JF가 제안한 방식을 이용해야 한다는 점에 착안하여, JF 방식을 이용하면 이를 차단하는 방식을 채택했습니다. (CreateHardLink 표준 API를 사용하지 않고 다른 방법으로 하드링크를 생성한다는 것은 분명 abnormal한 behavior라고 볼 수 있습니다.)</p>

<p>이런 방식을 적용하면, 하드링크를 활용하여 권한상승을 시도하는 (알려지지 않은 제로데이까지 포함한)해킹공격을 효과적으로 방어할 수 있습니다.</p>

<p>하드링크를 쓸 경우가 많지 않은데 하물며 CreateHardLink 표준을 사용하지 않는다면 굉장히 흔치 않은 행위라고 판단하는 겁니다. 거의 JF 방식은 일반(정상적인) 프로세스가 사용하는 경우가 거의 없습니다.</p>

<p>X-DIFFENSE는 커널레벨(파일시스템필터)에서 하드링크 생성 과정을 감시하고 차단합니다.</p>

<ul>
  <li>하드링크의 오용을 방지하는 방안</li>
</ul>


  
    
      <small><em>Guest post by: Yongil Lee of Diffense </em></small>
    
  
</article>





	  <script>
	    $("article").fitVids();
	    $('article p').each(function(i){
				if (($(this).find('img').length) && (!$.trim($(this).text()).length))  {
					$(this).addClass('img-only');
				}
				if ($.trim($(this).text()).length - $.trim($(this).find('small').text()).length == 0 && ($(this).find('img').length)){
					$(this).addClass('img-only-source');
				}
	  	});
	  </script>
	</div>
	<footer>
  <div class="inner">
    <p>This is the footer.<br><a href="http://steinvc.github.io/holo-alfa/">Holo Alfa</a> Jekyll theme crafted by <a href="http://steinvc.github.io/holo-alfa/">Stijn</a>.</p>
  </div>
</footer>

</body>
</html>
