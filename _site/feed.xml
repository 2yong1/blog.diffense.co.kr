<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DIFFENSE</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>A website with blog posts and pages</description>
    <pubDate>Tue, 06 Aug 2019 15:40:23 +0900</pubDate>
    
      <item>
        <title>DIFF-2019-005</title>
        <link>/2019/07/26/WD.html</link>
        <guid isPermaLink="true">/2019/07/26/WD.html</guid>
        <description>&lt;hr /&gt;

&lt;h2 id=&quot;development&quot;&gt;Development&lt;/h2&gt;

&lt;h3 id=&quot;infinityhook&quot;&gt;InfinityHook&lt;/h3&gt;

&lt;p&gt;안녕하세요. 독자 여러분. 지난 &lt;a href=&quot;http://blog.diffense.co.kr/2019/07/22/WD/&quot;&gt;DIFF-2019-004&lt;/a&gt;에서 “패치가드를 우회할 수 있는 커널후킹 라이브러리 InfinityHook”에 대한 내용을 얘기했었습니다. 이번 내용은 &lt;em&gt;InfinityHook&lt;/em&gt;을 빌드 및 실행하는 방법과 이것을 활용하는 방법에 대해 알아보고자 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 개발 환경&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아래와 같은 환경을 구축해서 테스트해보시길 권합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Windows 10 x64&lt;/li&gt;
  &lt;li&gt;Visual Studio 2019 Community Edition (&lt;a href=&quot;https://visualstudio.microsoft.com/downloads/&quot;&gt;다운로드&lt;/a&gt;)
    &lt;ul&gt;
      &lt;li&gt;“Desktop development with C++”를 반드시 선택해야 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Windows 10 SDK 10.0.18362.0 (&lt;a href=&quot;https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk&quot;&gt;다운로드&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;WDK (&lt;a href=&quot;https://docs.microsoft.com/ko-kr/windows-hardware/drivers/download-the-wdk&quot;&gt;다운로드&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;DbgView (&lt;a href=&quot;https://download.sysinternals.com/files/DebugView.zip&quot;&gt;다운로드&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Visual Studio, SDK, WDK 순으로 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;빌드&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;설치를 마쳤으면, 커널 드라이버 빌드 준비가 끝났습니다.&lt;/p&gt;

&lt;p&gt;빌드 절차는 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;InfinityHook&lt;/em&gt; 소스코드를 &lt;a href=&quot;https://github.com/everdox/InfinityHook/archive/master.zip&quot;&gt;다운로드&lt;/a&gt; 받습니다.&lt;/li&gt;
  &lt;li&gt;다운로드 받은 압축 파일을 적당한 폴더(예: C:\InfHook)에 풉니다.&lt;/li&gt;
  &lt;li&gt;프로젝트 파일(C:\InfHook\src\infinityhook.sln)을 더블클릭하여 비주얼스튜디오로 프로젝트를 오픈해주세요.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+Shift+B&lt;/code&gt; 를 눌러 빌드합니다.  빌드가 성공하였다면 다음 그림과 같은 빌드 메시지를 볼 수 있을 것입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/61880097-36d89c80-af2f-11e9-91b4-9a8362fe278a.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;빌드 간단하네요. 빌드된 커널 드라이버 경로는 C:\InfHook\src\x64\Debug\kinfinityhook.sys 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테스트&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;빌드된 커널드라이버는 아래와 같은 후킹 코드 샘플을 포함하고 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// NtCreateFile 후킹 함수
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTSTATUS&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DetourNtCreateFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// We're going to filter for our &quot;magic&quot; file name.
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ObjectAttributes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ObjectAttributes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ObjectName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ObjectAttributes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ObjectName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 파일명이 &quot;ifh--&quot;을 포함한다면?
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wcsstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ObjectName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IfhMagicFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;kprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[+] infinityhook: Denying access to file: %wZ.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ObjectAttributes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ObjectName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;ExFreePool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ObjectName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// 접근 차단
&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STATUS_ACCESS_DENIED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 원본 NtCreateFile 함수 호출
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OriginalNtCreateFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DesiredAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ObjectAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IoStatusBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AllocationSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShareAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateDisposition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EaBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EaLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NtCreateFile&lt;/code&gt;을 후킹하여, 특정 파일명(&lt;code class=&quot;highlighter-rouge&quot;&gt;ifh--&lt;/code&gt;)을 포함한 파일은 접근 차단되도록 작성되어 있음을 알 수 있습니다.  커널드라이버(&lt;code class=&quot;highlighter-rouge&quot;&gt;kinfinityhook.sys&lt;/code&gt;)를 로드하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;ifh--&lt;/code&gt; 파일을 정말 차단할 수 있는지 확인해 보겠습니다.&lt;/p&gt;

&lt;p&gt;지금 빌드된 드라이버는 테스트용 인증서로 서명된 드라이버(test-signed driver)라서, 커널드라이버가 로드될 수 있도록 윈도우즈 부트 설정을 바꿔줘야 합니다. 관리자 권한의 cmd.exe 를 열고 다음 2줄을 실행합니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bcdedit.exe /set loadoptions DISABLE_INTEGRITY_CHECKS
bcdedit.exe /set TESTSIGNING ON
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그리고 재부팅합니다. 재부팅 후,  테스트용 파일(&lt;code class=&quot;highlighter-rouge&quot;&gt;ifh--xxxx.txt&lt;/code&gt;)을 바탕화면에 만들어주세요. 내용은 어떤 내용이든 상관없습니다. 메모장으로 해당 파일이 열리는 것을 확인해주세요.&lt;/p&gt;

&lt;p&gt;이제 드라이버를 로드해보겠습니다. 관리자 권한의 cmd.exe 창을 띄우고 다음 명령을 입력해주세요. (binpath= type= 사이에 공백이 있다는 점 주의하세요.)&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:&lt;span class=&quot;se&quot;&gt;\I&lt;/span&gt;nfHook&lt;span class=&quot;se&quot;&gt;\s&lt;/span&gt;rc&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;64&lt;span class=&quot;se&quot;&gt;\D&lt;/span&gt;ebug&amp;gt;sc create infhook &lt;span class=&quot;nv&quot;&gt;binpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; C:&lt;span class=&quot;se&quot;&gt;\I&lt;/span&gt;nfHook&lt;span class=&quot;se&quot;&gt;\s&lt;/span&gt;rc&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;64&lt;span class=&quot;se&quot;&gt;\D&lt;/span&gt;ebug&lt;span class=&quot;se&quot;&gt;\k&lt;/span&gt;infinityhook.sys &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; kernel
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;SC] CreateService 성공

C:&lt;span class=&quot;se&quot;&gt;\I&lt;/span&gt;nfHook&lt;span class=&quot;se&quot;&gt;\s&lt;/span&gt;rc&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;64&lt;span class=&quot;se&quot;&gt;\D&lt;/span&gt;ebug&amp;gt;sc start infhook

SERVICE_NAME: infhook
        종류               : 1  KERNEL_DRIVER
        상태               : 4  RUNNING
                                &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        WIN32_EXIT_CODE    : 0  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        SERVICE_EXIT_CODE  : 0  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        검사점             : 0x0
        WAIT_HINT          : 0x0
        PID                : 0
        플래그             :

C:&lt;span class=&quot;se&quot;&gt;\I&lt;/span&gt;nfHook&lt;span class=&quot;se&quot;&gt;\s&lt;/span&gt;rc&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;64&lt;span class=&quot;se&quot;&gt;\D&lt;/span&gt;ebug&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;상태가 &lt;em&gt;RUNNING&lt;/em&gt;으로 출력되면 &lt;em&gt;infinityhook&lt;/em&gt; 드라이버가 제대로 로드가 된 것입니다. 지금부터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ifh--xxxx.txt&lt;/code&gt;가 차단되어야 하겠죠?&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ifh--xxxx.txt&lt;/code&gt;을 열어보면 아래 그림처럼 파일이 열리지 않는 것을 확인해볼 수 있습니다. 
&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/61878962-0132b400-af2d-11e9-86b3-8fcd84b2d528.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;잘되는군요! 테스트를 마쳤으니, 다음과 같이 드라이버를 언로드하겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:&lt;span class=&quot;se&quot;&gt;\I&lt;/span&gt;nfHook&lt;span class=&quot;se&quot;&gt;\s&lt;/span&gt;rc&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;64&lt;span class=&quot;se&quot;&gt;\D&lt;/span&gt;ebug&amp;gt;sc stop infhook

SERVICE_NAME: infhook
        종류               : 1  KERNEL_DRIVER
        상태              : 1  STOPPED
        WIN32_EXIT_CODE    : 0  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        SERVICE_EXIT_CODE  : 0  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0x0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        검사점         : 0x0
        WAIT_HINT          : 0x0

C:&lt;span class=&quot;se&quot;&gt;\I&lt;/span&gt;nfHook&lt;span class=&quot;se&quot;&gt;\s&lt;/span&gt;rc&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;64&lt;span class=&quot;se&quot;&gt;\D&lt;/span&gt;ebug&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 &lt;em&gt;infinityhook&lt;/em&gt;을 수정해서 다른 시스템콜을 후킹하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;네버다이 메모장&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;네버다이 메모장을 구현해보면서 &lt;em&gt;infinityhook&lt;/em&gt;을 이용해 시스템콜을 후킹하는 방법을 살펴보겠습니다.  네버다이 메모장은 이름 그대로 절대 죽지 않는 메모장입니다.(스스로 종료하는 것은 허용합니다.) 이것을 구현하기 위해선 프로세스의 종료를 담당하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;nt!NtTerminateProcess&lt;/code&gt; 시스템콜을 후킹해야 합니다.&lt;/p&gt;

&lt;p&gt;기존 샘플 코드에서 SyscallStub 함수 부분만 다음과 같이 수정해주면 시스템콜 후킹을 추가로 구현해볼 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__fastcall&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SyscallStub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SystemCallIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Inout_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SystemCallFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SystemCallIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*후킹하길 원하는 시스템콜 인덱스*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SystemCallFunction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*후킹 함수*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;후킹하려는 시스템콜의 서비스테이블 인덱스을 알아봐야 하겠죠?  윈도우즈 시스템 콜 인덱스 리스트는 Google P0의 j00ru가 &lt;a href=&quot;https://j00ru.vexillium.org/syscalls/nt/64/&quot;&gt;여기&lt;/a&gt;에 잘 정리해놓았습니다.
&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/61920944-5656e000-af96-11e9-959e-42de07319d78.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NtTerminateProcess&lt;/code&gt;의 인덱스는 0x2c 군요. SyscallStub 함수는 다음과 같은 형태가 될 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__fastcall&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SyscallStub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SystemCallIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Inout_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SystemCallFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SystemCallIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2c&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*NtTerminateProcess 인덱스*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 원본 NtTerminateProcess 주소를 백업
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OrigNtTerminateProcess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;OrigNtTerminateProcess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NtTerminateProcess_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SystemCallFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// NtTerminateProcess 함수 콜을 후킹 함수(DetourNtTerminateProcess)로 바꿔준다.
&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SystemCallFunction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DetourNtTerminateProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그럼, 소스코드(C:\InfHook\src\kinfinityhook\entry.cpp) 전체를 다음과 같이 재작성해주세요. 
코드설명은 주석으로 대신하겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;stdafx.h&quot;
#include &quot;entry.h&quot;
#include &quot;infinityhook.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTSTATUS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTAPI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NtTerminateProcess_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTSTATUS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExitStatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NtTerminateProcess_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OrigNtTerminateProcess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;NTSTATUS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DetourNtTerminateProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTSTATUS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExitStatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PCHAR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PsGetProcessImageFileName_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PEPROCESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PsGetProcessImageFileName_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PsGetProcessImageFileName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 드라이버 메인
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;NTSTATUS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DriverEntry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PDRIVER_OBJECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DriverObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PUNICODE_STRING&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegistryPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UNREFERENCED_PARAMETER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RegistryPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;kprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[+] infinityhook: Loaded.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 드라이버 언로드 핸들러 등록
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;DriverObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DriverUnload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DriverUnload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 후킹 시작(시스템콜이 발생하면, SyscallStub 함수로 제어권이 넘어감)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NTSTATUS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IfhInitialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SyscallStub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NT_SUCCESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[-] infinityhook: Failed to initialize with status: 0x%lx.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 드라이버 언로드할 때
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DriverUnload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PDRIVER_OBJECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DriverObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UNREFERENCED_PARAMETER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DriverObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 후킹 종료
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;IfhRelease&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;kprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;[!] infinityhook: Unloading... BYE!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__fastcall&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SyscallStub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SystemCallIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Inout_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SystemCallFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SystemCallIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2c&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*NtTerminateProcess 인덱스*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 원본 NtTerminateProcess 주소를 백업
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OrigNtTerminateProcess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;OrigNtTerminateProcess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NtTerminateProcess_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SystemCallFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// NtTerminateProcess 함수 콜을 후킹 함수(DetourNtTerminateProcess)로 바꿔준다.
&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SystemCallFunction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DetourNtTerminateProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// NtTerminateProcess 후킹 함수
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTSTATUS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DetourNtTerminateProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTSTATUS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExitStatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;kprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HookNtTerminateProcess Entry&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 원본 NtTerminateProcess 호출
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OrigNtTerminateProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExitStatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로세스가 종료될 때(&lt;code class=&quot;highlighter-rouge&quot;&gt;NtTerminateProcess&lt;/code&gt;가 호출될 때), &lt;code class=&quot;highlighter-rouge&quot;&gt;DetourNtTerminateProcess&lt;/code&gt; 후킹 함수가 제어권을 가로챌 수 있도록 작성된 코드입니다. 지금은 커널로그만 출력하고 어떤 행위도 하지 않도록 되어 있죠.&lt;/p&gt;

&lt;p&gt;후킹이 제대로 되는지 확인해 볼까요? 우선 DbgView를 관리자 권한으로 실행하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+K&lt;/code&gt;를 눌러 커널 로그를 덤프뜰 수 있도록 해줍니다. 다음, 새로 작성한 코드를 빌드해봅시다. 비주얼스튜디오에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+Shift+B&lt;/code&gt;를 눌러주세요. 빌드 완료 후, 관리자 cmd 에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;net start infhook&lt;/code&gt; 을 실행하여 새로 작성한 커널드라이버를 다시 로드해줍니다. 프로세스를 몇 개 종료해보면, 아래와 같이 DbgView에 로그메시지가 제대로 출력되는 것을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/61901086-f4788500-af59-11e9-897f-5b4e82e57975.png&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제대로 후킹이 걸려진 것 같군요. 걸려진 것을 확인했으니 &lt;code class=&quot;highlighter-rouge&quot;&gt;net stop infhook&lt;/code&gt; 명령으로 커널 드라이버를 언로드시켜주세요.&lt;/p&gt;

&lt;p&gt;이제 후킹 함수(&lt;code class=&quot;highlighter-rouge&quot;&gt;DetourNtTerminateProcess&lt;/code&gt;)를 다음과 같이 재작성 해보겠습니다. 소스코드 설명은 주석으로 대신하겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// NtTerminateProcess 후킹 함수
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTSTATUS&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DetourNtTerminateProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NTSTATUS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExitStatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;NTSTATUS&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;rtStatus&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STATUS_SUCCESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PEPROCESS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pEProcess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PCHAR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pStrProcName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 프로세스가 스스로 종료되는 것은 허용한다.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NtCurrentProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OrigNtTerminateProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExitStatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 프로세스 핸들로부터 EPROCESS 구조체의 주소를 구한다.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;rtStatus&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ObReferenceObjectByHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FILE_READ_DATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KernelMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PVOID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pEProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NT_SUCCESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rtStatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pEProcess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OrigNtTerminateProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExitStatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// EPROCESS 로부터 프로세스명을 구한다.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PsGetProcessImageFileName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;UNICODE_STRING&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringPsGetProcessImageFileName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTL_CONSTANT_STRING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;L&quot;PsGetProcessImageFileName&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;PsGetProcessImageFileName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PsGetProcessImageFileName_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MmGetSystemRoutineAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StringPsGetProcessImageFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;pStrProcName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PsGetProcessImageFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pEProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pStrProcName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strcmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pStrProcName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;notepad.exe&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// EPROCESS 구조체 참조 해제
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;ObReferenceObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pEProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// 메모장(notepad.exe)이 종료되는 것을 막는다.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STATUS_SUCCESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 원본 NtTerminateProcess 호출
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OrigNtTerminateProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExitStatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드를 다시 빌드(&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+Shif+B&lt;/code&gt;)하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;net start infhook&lt;/code&gt; 으로 드라이버를 로드해보세요.&lt;/p&gt;

&lt;p&gt;다음처럼 불멸의 메모장을 보실 수 있습니다!&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/-igmNVJtWCs&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;strong&gt;참고자료&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/everdox/InfinityHook&quot;&gt;InfinityHook&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Cody2333/SSDT_HOOK/blob/master/ssdt.c&quot;&gt;SSDT Hook Code&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://j00ru.vexillium.org/syscalls/nt/64/&quot;&gt;Windows X86-64 System Call Table (XP/2003/Vista/2008/7/2012/8/10)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/sc-create&quot;&gt;Sc command&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows-hardware/drivers/install/the-testsigning-boot-configuration-option&quot;&gt;Enable Loading of Test Signed Drivers&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/20552300/hook-zwterminateprocess-in-x64-driver-without-ssdt&quot;&gt;RegisterCallbackFunction&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 26 Jul 2019 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>DIFF-2019-004</title>
        <link>/2019/07/22/WD.html</link>
        <guid isPermaLink="true">/2019/07/22/WD.html</guid>
        <description>&lt;hr /&gt;

&lt;h2 id=&quot;technologies&quot;&gt;Technologies&lt;/h2&gt;

&lt;h3 id=&quot;infinityhook&quot;&gt;InfinityHook&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Kernel_Patch_Protection&quot;&gt;&lt;em&gt;PatchGuard&lt;/em&gt;&lt;/a&gt;를 우회할 수 있는 윈도우즈 커널 후킹 라이브러리가 최근 공개되었습니다.&lt;/p&gt;

&lt;p&gt;커널 후킹 기술은 보안 제품이나 루트킷에서 거의 필수적으로 사용되어 왔습니다. 과거에는 &lt;em&gt;SSDT, IDT&lt;/em&gt; 등의 시스템 테이블 변조를 통해 구현하는 방식이 일반적이었는데, MS가 &lt;em&gt;PatchGuard&lt;/em&gt;를 도입하고 나서부터 기존의 커널 후킹 방식이 불가능해졌습니다.&lt;/p&gt;

&lt;p&gt;이러한 상황에서 공개된 &lt;a href=&quot;https://github.com/everdox/InfinityHook&quot;&gt;&lt;em&gt;InfinityHook&lt;/em&gt;&lt;/a&gt;은 &lt;em&gt;PatchGuard&lt;/em&gt;를 우회할 수 있는 윈도우즈 커널 후킹 라이브러리로서, Win7~Win10을 지원하고 시스템콜,컨텍스트스위치,페이지폴트 핸들러 등을 후킹할 수 있습니다.&lt;/p&gt;

&lt;p&gt;사용하기 쉽게 잘 만들어져 있어 해당 기술을 해커들이 차용할 가능성이 있습니다. 방어자 입장에선 어떻게 탐지할 것인지 고민해야 할 것으로 보입니다..&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테스트&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;InfinityHook&lt;/em&gt;은 커널 라이브러리이므로, 이것을 테스트해보려면 커널드라이버를 만들어야 합니다. 커널 드라이버의 큰 골격은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* 드라이버 메인 함수입니다. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;NTSTATUS&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DriverEntry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PDRIVER_OBJECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DriverObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PUNICODE_STRING&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegistryPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 드라이버 언로드 핸들러 등록
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;DriverObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DriverUnload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DriverUnload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  

    &lt;span class=&quot;c1&quot;&gt;// NtCreateFile 주소
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;OriginalNtCreateFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NtCreateFile_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MmGetSystemRoutineAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StringNtCreateFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// InfinityHook을 시작합니다.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;IfhInitialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SyscallStub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* 드라이버 언로드시 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DriverUnload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PDRIVER_OBJECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DriverObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// InfinityHook을 종료합니다.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;IfhRelease&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;       
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 시스템콜호출 -&amp;gt; 시스템콜디스패처(KiSystemCall64) -&amp;gt; ETW 로깅(PerfInfoLogSysCallEntry)-&amp;gt; GetCpuClock -&amp;gt;
// InfinityHook 라이브러리(IfhpInternalGetCpuClock) -&amp;gt; SyscallStub
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;__fastcall&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SyscallStub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SystemCallIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Inout_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SystemCallFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 원하는 시스템콜(예: NtCreateFile)이 호출되면
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SystemCallFunction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OriginalNtCreateFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SystemCallFunction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DetourNtCreateFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 후킹함수로 교체
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 후킹 함수
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NTSTATUS&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DetourNtCreateFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;_Out_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PHANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ACCESS_MASK&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DesiredAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POBJECT_ATTRIBUTES&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ObjectAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;_Out_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PIO_STATUS_BLOCK&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IoStatusBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;_In_opt_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PLARGE_INTEGER&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AllocationSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ULONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ULONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShareAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ULONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateDisposition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ULONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;_In_reads_bytes_opt_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EaLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PVOID&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EaBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;_In_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ULONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EaLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/*
        여기서 원하는 작업 수행
    */&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 원본 함수 호출
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OriginalNtCreateFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DesiredAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ObjectAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IoStatusBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AllocationSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ShareAccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateDisposition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EaBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EaLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;InfinityHook&lt;/em&gt;을 &lt;a href=&quot;https://github.com/everdox/InfinityHook/archive/master.zip&quot;&gt;공식 홈페이지&lt;/a&gt;에서 다운로드 받습니다.&lt;/p&gt;

&lt;p&gt;WDK 위치: https://docs.microsoft.com/ko-kr/windows-hardware/drivers/download-the-wdk&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;후킹방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;InfinityHook&lt;/em&gt;의 후킹 방식을 좀 살펴볼까요? 후킹은 &lt;em&gt;ETW(Event Tracing For Windows)&lt;/em&gt;와 관련이 있습니다. &lt;em&gt;ETW&lt;/em&gt;는 윈도우즈 시스템에서 발생하는 이벤트를 수집해주는 기능으로, 이벤트 추적을 위해 시스템 전역에 이벤트 수집 코드를 정적으로 삽입해 놓았습니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ETW&lt;/em&gt;는 시스템콜 호출 이벤트 역시 수집할 수 있습니다. 이를 위해 모든 시스템콜의 커널 진입점이 되는 시스템콜 디스패처(&lt;code class=&quot;highlighter-rouge&quot;&gt;KiSystemCall64&lt;/code&gt;)에다 이벤트 수집 함수(&lt;code class=&quot;highlighter-rouge&quot;&gt;PerfInfoLogSysCallEntry&lt;/code&gt;)를 아래 그림처럼 삽입해 놓습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/everdox/InfinityHook/raw/master/resources/perf.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;[출처: InfinityHook github]&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PerfInfoLogSysCallEntry&lt;/code&gt; 내부에선 &lt;code class=&quot;highlighter-rouge&quot;&gt;_WMI_LOGGER_CONTEXT&lt;/code&gt; 구조체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;GetCpuClock&lt;/code&gt; 함수포인터를 호출하는데, &lt;em&gt;InfinityHook&lt;/em&gt;은 바로 이 함수 포인터를 덮어쓰는 방식으로 제어권을 가로챕니다. 결국 모든 시스템콜이 호출될 때마다 &lt;em&gt;InfinityHook&lt;/em&gt;이 제어권을 가로챌 수 있도록 한 것이죠. &lt;em&gt;PatchGuard&lt;/em&gt;는 정적으로 생성된 주요 시스템 테이블이나 코드 영역에 대해서 Coarse-grained하게 변조 행위를 감시할 수 있지만, 동적으로 생성되는 이런 종류의 데이터스트럭쳐들 하나하나를 Fine-grained하게 보호하지는 못하는 것으로 보입니다. 성능 문제 때문이겠지요.&lt;/p&gt;

&lt;p&gt;제어권을 가로챈 후 &lt;em&gt;InfinityHook&lt;/em&gt;이 하는 일은, 커널스레드 스택을 조사해서 원본 시스템콜핸들러 주소가 저장된 스택위치(그림에서 보면 첫번째 빨간색 화살표)를 찾아낸 후 해당 스택의 값을 후킹함수의 주소로 덮어씁니다. 이후 &lt;code class=&quot;highlighter-rouge&quot;&gt;call r10&lt;/code&gt;(세번째 빨간색)이 실행되면, 원본시스템콜핸들러 대신 후킹함수가 최종적으로 호출되도록 구현되어 있습니다.&lt;/p&gt;

&lt;p&gt;InfinityHook의 단점은 시스템콜이 불릴 때마다 후킹을 위해 스택 조사 작업(Stack Walking)을 동반하기 때문에 예전 후킹방식에 비해 시스템 성능을 떨어뜨릴 수 있다는 점입니다.&lt;/p&gt;

&lt;p&gt;감히(?) 단점을 언급하였지만, 커널 후킹 기술을 공개하였다는 사실만으로도 리서쳐들에겐 감사한 일인 것은 분명합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;참고자료&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/everdox/InfinityHook&quot;&gt;InfinityHook, github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;vulnerability&quot;&gt;Vulnerability&lt;/h2&gt;

&lt;h3 id=&quot;dell-lpe-취약점cve-2019-3735&quot;&gt;&lt;a href=&quot;https://d4stiny.github.io/Local-Privilege-Escalation-on-most-Dell-computers/&quot;&gt;Dell LPE 취약점(CVE-2019-3735)&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Bill Demirkapi라는 17살의 보안 연구원이 윈도우즈가 설치된 Dell PC에서의 권한상승 취약점에 대한 내용을 지난 6월말에 캐나다에서 개최된 Recon 컨퍼런스와 본인의 블로그를 통해 공개했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;70%&quot; src=&quot;https://user-images.githubusercontent.com/5102989/61612914-d4676e00-ac9a-11e9-83b0-3fac062b7707.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;[출처: d4stiny.github.io]&lt;/p&gt;

&lt;p&gt;Dell PC에는 SupportAssist라는 프로그램이 미리 설치가 되어 있습니다. SupportAssist는 주기적으로 시스템의 상태를 체크하고 사용자에게 업데이트 알람도 주며 버전에 맞는 드라이버도 자동으로 설치해주는 프로그램입니다.&lt;/p&gt;

&lt;p&gt;Bill은 바로 이 프로그램에서 권한상승 취약점을 발견했습니다. Bill은 지난 5월에 동일한 프로그램에서 RCE 취약점을 발견하여 &lt;a href=&quot;https://d4stiny.github.io/Remote-Code-Execution-on-most-Dell-computers&quot;&gt;공개&lt;/a&gt;하기도 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;취약점&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SupportAssistAgent.exe&lt;/code&gt;는 시스템 서비스로 실행되며, 자식 프로세스로 &lt;code class=&quot;highlighter-rouge&quot;&gt;SupportAssistAppWire.exe&lt;/code&gt;를 실행시킵니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/5102989/61609402-fbb93d80-ac90-11e9-92da-954a8eb20b46.png&quot; alt=&quot;SupportAssistAgentProcess&quot; /&gt;&lt;/p&gt;

&lt;p&gt;[출처: d4stiny.github.io]&lt;/p&gt;

&lt;p&gt;권한상승 취약점의 원인은 자식 프로세스가 생성될 때 상속받은 부모프로세스(시스템프로세스)의 스레드 핸들에 모든 권한(full control)이 주어졌다는 데 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/5102989/61609456-25726480-ac91-11e9-932e-b539911a4af7.png&quot; alt=&quot;thread_handle_properties&quot; /&gt;&lt;/p&gt;

&lt;p&gt;[출처: d4stiny.github.io]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;익스플로잇 절차&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;시스템 프로세스의 스레드에 대한 모든 권한(full control)을 가진 취약점을 악용하여 다음과 같은 절차를 통해 최종적으로 권한상승 할 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;자식 프로세스(&lt;code class=&quot;highlighter-rouge&quot;&gt;SupportAssistAppWire.exe&lt;/code&gt;)의 실행을 감시합니다.&lt;/li&gt;
  &lt;li&gt;자식 프로세스가 실행되면, Dll Injection을 통해 자식 프로세스에 코드를 삽입합니다.&lt;/li&gt;
  &lt;li&gt;삽입된 코드는 상속받은 부모프로세스(&lt;code class=&quot;highlighter-rouge&quot;&gt;SupportAssistAgent.exe&lt;/code&gt;)의 스레드 핸들을 찾습니다.&lt;/li&gt;
  &lt;li&gt;부모프로세스의 스레드 핸들을 이용해, SetThreadContext를 호출하여 부모프로세스의 스레드 실행 컨텍스트를 다음과 같이 변경합니다.
    &lt;ul&gt;
      &lt;li&gt;RIP값을 NtTestAlert로 변경&lt;/li&gt;
      &lt;li&gt;해당 스레드는 현재 Wait 상태라 RIP값을 바꾼다고 바로 실행되지는 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부모프로세스의 스레드 핸들을 이용해, LoadLibrary를 엔트리로 하는 APC를 등록합니다.&lt;/li&gt;
  &lt;li&gt;부모프로세스에 시그널을 보내 스레드의 Wait 상태를 깨웁니다.
    &lt;ul&gt;
      &lt;li&gt;자식 프로세스가 시그널을 보낼 수 있었던 것은 부모프로세스가 Interactive 그룹에 속해 있어, 자식 프로세스도 시그널을 보낼 수 있는 권한이 있었기 때문입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드가 깨어나면 NtTestAlert이 실행되고, NtTestAlert는 큐에 등록되어 있던 APC를 꺼내 실행합니다.&lt;/li&gt;
  &lt;li&gt;APC로 LoadLibrary가 실행되어 페이로드 DLL이 최종적으로 부모프로세스상에서 실행됩니다.
    &lt;ul&gt;
      &lt;li&gt;Bill은 부모프로세스의 sqlite3.dll이 사용하는 파일 경로 중에서 사용자가 쓸 수 있는 경로를 찾아냈고, 해당 경로를 페이로드 DLL로 덮어씁니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 22 Jul 2019 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>DIFF-2019-003</title>
        <link>/2019/07/12/WD.html</link>
        <guid isPermaLink="true">/2019/07/12/WD.html</guid>
        <description>&lt;hr /&gt;

&lt;h2 id=&quot;issues&quot;&gt;Issues&lt;/h2&gt;

&lt;h3 id=&quot;zoom-취약점&quot;&gt;Zoom 취약점&lt;/h3&gt;

&lt;p&gt;Jonathan Leitschuh이란 연구원이 Zoom 서비스 취약점을 7월 9일자로 공개했습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;요약&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Zoom의 Mac 클라이언트에서 원격 취약점이 발견됨&lt;/li&gt;
  &lt;li&gt;여러 취약점 중에서 &lt;u&gt;사용자의 웹캠을 노출&lt;/u&gt;시킬 수 있는 취약점이 가장 크리티컬함&lt;/li&gt;
  &lt;li&gt;2015년 기준으로 약 4천만명이 Zoom을 사용하고 PC 시장에서 대략 10% 정도가 Mac 유저라고 볼 때, &lt;u&gt;최소 4백만명&lt;/u&gt; 정도의 Mac 사용자가 해당 취약점에 영향을 받는다고 추산&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;취약점&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;취약점 원인은 Mac 클라이언트를 설치할 때 같이 설치되는 &lt;b&gt;&lt;u&gt;로컬 웹서버&lt;/u&gt;&lt;/b&gt;(포트19421)에 있습니다.&lt;/p&gt;

&lt;p&gt;해커는 다음과 같은 스크립트를 통해 Zoom 사용자 PC의 로컬 웹서버에 요청을 보낼 수 있고, 사용자 동의 없이 해커가 만들어놓은 채널에 사용자를 조인시킬 수 있습니다. 사용자의 웹캠이 켜진 상태로 말이죠.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://localhost:19421/launch?action=join&amp;amp;confno=492468757&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음 그림처럼 참여자의 웹캠을 켜는 권한이 채널을 만드는 사람(해커)에게 있었기 때문에,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1750/1*3v6fVs6FM39EDWQUBK2s4w.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 스크립트를 통해 사용자를 채널로 유인하면 자동으로 웹캠이 켜진 상태로 조인되었던 것이죠.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;해결책&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;제로데이 상태로 공개가 되었기 때문에 현재까지도 많은 이슈가 되고 있습니다. Mac 사용자들은 Zoom 클라이언트를 삭제하면 되겠다라고 생각할지도 모르겠습니다. 하지만 더 문제가 된 것은 사용자가 &lt;u&gt;Mac 클라이언트를 삭제해도 로컬 웹서버는 삭제되지 않고 살아있다&lt;/u&gt;는 점인데요. Mac 클라이언트를 삭제해도 여전히 해당 취약점에 노출되어 있는 상태였던 것이죠.&lt;/p&gt;

&lt;p&gt;그래서 로컬 웹서버까지 확실히 제거할 수 있는 방법이 사용자들 사이에서 공유되었습니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;lsof &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt;:19421
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-9&lt;/span&gt; &amp;lt;pid&amp;gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rm &lt;span class=&quot;nt&quot;&gt;-rf&lt;/span&gt; ~/.zoomus
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;touch ~/.zoomus
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;19421 포트의 프로세스를 먼저 죽이고, zoom 관련 디렉토리(~/.zoomus)를 제거하는 것입니다.&lt;/p&gt;

&lt;p&gt;취약점 타임라인 및 더 자세한 내용은 Jonathan의 블로그, &lt;a href=&quot;https://medium.com/bugbountywriteup/zoom-zero-day-4-million-webcams-maybe-an-rce-just-get-them-to-visit-your-website-ac75c83f4ef5&quot;&gt;“Zoom Zero Day: 4+ Million Webcams &amp;amp; maybe an RCE? Just get them to visit your website!”&lt;/a&gt;를 참고해주세요.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;issues-1&quot;&gt;Issues&lt;/h2&gt;

&lt;h3 id=&quot;애플의-사일런트-업데이트&quot;&gt;애플의 사일런트 업데이트&lt;/h3&gt;

&lt;p&gt;Zoom 클라이언트를 삭제해도 Zoom의 로컬 웹서버가 삭제되지 않고 살아있는 문제를 해결하기 위해 애플이 직접 나섰습니다. 바로 MacOS의 사일런트 업데이트를 통해 Zoom 클라이언트의 로컬 웹서버를 제거하기로 한 것인데요. OS에서 사일런트 업데이트를 통해 타사의 제품을 제거한 사례는 매우 이례적이라 큰 이슈(&lt;a href=&quot;https://techcrunch.com/2019/07/10/apple-silent-update-zoom-app/&quot;&gt;Apple has pushed a silent Mac update to remove hidden Zoom web server&lt;/a&gt;)가 되었습니다.&lt;/p&gt;

&lt;p&gt;사일런트 업데이트는 MacOS에서 사용하는 MRT(Malware Removal Tool)이라는 악성코드제거도구의 패턴업데이트로 밝혀졌습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/61099922-07418300-a49f-11e9-8298-0a09453c07f1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Zoom 클라이언트 제거 패턴은 MRTConfigData 1.45 버전에서 업데이트되었습니다.&lt;/p&gt;

&lt;p&gt;패턴 내용은 MRT 앱(&lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/CoreServices/MRT.app&lt;/code&gt;)의 실행 바이너리를 분석해보면 알 수 있습니다. 
objective-see 운영자로 유명한 patrick wardle의 &lt;a href=&quot;https://twitter.com/patrickwardle/status/1149176886817255424&quot;&gt;트윗&lt;/a&gt;에서 패턴명(“MACOS.354c063”)을 언급하고 있는데요. hopper 등의 디스어셈블리를 사용해서 해당 패턴명을 참조하는 곳을 보면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/61100363-e1b57900-a4a0-11e9-9530-825104f9f7e2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/61100428-16293500-a4a1-11e9-85a9-ebf7f6424de1.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 문자열을 패턴으로 사용하고 있음을 알 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/.zoomus/ZoomOpener.app/Contents/MacOS/ZoomOpener
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;패턴 테스트를 위해 ~/.zoomus 아래에 ZoomOpener 파일(로컬웹서버)을 만들고 실행해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mkdir &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; ~/.zoomus/ZoomOpener.app/Contents/MacOS/
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/.zoomus/ZoomOpener.app/Contents/MacOS/
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;void main() { getchar(); }&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; ZoomOpener.c
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;clang ZoomOpener.c &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; ZoomOpener
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./ZoomOpener
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;MRT를 실행합니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./MRT &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;                  
2019-07-12 12:43:02.952 MRT[6575:173083] Running as agent
2019-07-12 12:43:03.037 MRT[6575:173083] failed to check loginItems
2019-07-12 12:43:03.196 MRT[6575:173083] Found MACOS.354c063 infection.
/Users/diff/.zoomus/ZoomOpener.app/Contents/MacOS/ZoomOpener: Process killed
2019-07-12 12:43:03.198 MRT[6575:173083] Found MACOS.354c063 infection.
/Users/diff/.zoomus: Directory removed
2019-07-12 12:43:03.198 MRT[6575:173083] Found MACOS.354c063 infection.
/Users/diff/.zoomus: Directory recreated
2019-07-12 12:43:03.199 MRT[6575:173083] Agent finished.
2019-07-12 12:43:03.199 MRT[6575:173083] Finished MRT run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;MACOS.354c063 감염을 발견했다는 메시지를 볼 수 있고, ZoomOpener(로컬웹서버) 프로세스를 죽이고 관련 디렉토리(~/.zoomus)를 제거했다는 것을 로그를 통해 확인할 수 있네요.&lt;/p&gt;

&lt;p&gt;Filemon 로그도 확인해보겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo&lt;/span&gt; ./filemon &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; zoomus

Adding File filter 0: zoomus
 6575 MRT	Deleted        /Users/diff/.zoomus/ZoomOpener.app/Contents/MacOS/ZoomOpener
 6575 MRT	Deleted        /Users/diff/.zoomus/ZoomOpener.app/Contents/MacOS/ZoomOpener.c
 6575 MRT	Deleted        /Users/diff/.zoomus/ZoomOpener.app/Contents/MacOS
 6575 MRT	Deleted        /Users/diff/.zoomus/ZoomOpener.app/Contents
 6575 MRT	Deleted        /Users/diff/.zoomus/ZoomOpener.app
 6575 MRT	Deleted        /Users/diff/.zoomus
 6575 MRT	Created dir    /Users/diff/.zoomus
 6575 MRT	Chowned        /Users/diff/.zoomus
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Zoom 클라이언트 제거를 위해 MacOS 사일런트 업데이트가 이루어진 사실을 확인해보았습니다. MRT가 동작하는 시점이 확인되지는 않았으나, Zoom 클라이언트의 로컬웹서버가 설치되어있다면 사용자 인지없이 백그라운드에서 제거가 될 것입니다.&lt;/p&gt;

&lt;p&gt;참고자료:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.sentinelone.com/blog/apples-malware-removal-mrt-tool-update/&quot;&gt;APPLE MALWARE: UNCOVERING THE MYSTERIOUS REMOVAL (MRT) TOOL UPDATE&lt;/a&gt;, SentinelOne&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://discussions.apple.com/thread/250079600&quot;&gt;What is this MRTConfigData&lt;/a&gt;, Apple&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/patrickwardle/status/1149176886817255424&quot;&gt;patrick wardle’s tweet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 12 Jul 2019 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>DIFF-2019-002</title>
        <link>/2019/07/02/Weekly-Diffense.html</link>
        <guid isPermaLink="true">/2019/07/02/Weekly-Diffense.html</guid>
        <description>&lt;hr /&gt;

&lt;h1 id=&quot;vulnerabilities&quot;&gt;Vulnerabilities&lt;/h1&gt;

&lt;h3 id=&quot;attacking-intels-transactional-synchronization-extensions&quot;&gt;&lt;a href=&quot;https://blog.ret2.io/2019/06/26/attacking-intel-tsx&quot;&gt;Attacking Intel’s Transactional Synchronization Extensions&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Pwn2Own 2018 우승팀으로도 유명한 ret2system에서 &lt;strong&gt;Intel TSX 버그&lt;/strong&gt;를 발견하였습니다.
재미있는 사실은 Defcon CTF 문제를 풀다가 발견하였다는 것인데요.&lt;/p&gt;

&lt;p&gt;우선 Intel TSX에 대해 설명드리고, ret2system에서 발견한 CPU 버그와 이를 이용해 CTF 문제를 어떻게 해결하였는지를 설명하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Intel TSX?&lt;/strong&gt;&lt;br /&gt;
Intel의 TSX(Transactional Synchronization eXtensions)은 멀티스레드의 동기화 문제를 간소화시키는 데 도움을 주는 하드웨어 기술입니다.&lt;/p&gt;

&lt;p&gt;다음 예는 Intel에서 발표한 내용의 일부를 가져온 것인데요.
&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/60555722-23e00b80-9d79-11e9-8359-41f5db8d02f1.png&quot; width=&quot;80%&quot; height=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2개의 스레드(Alice, Bob)가 공유자원(Table)에 동시에 접근할 경우, 원치 않는 결과(-10)가 나올 수 있음을 왼쪽 그림이 보여주고 있습니다. 이를 해결하기 위해 개발자들은 보통 오른쪽 그림처럼 Lock을 사용하죠.&lt;/p&gt;

&lt;p&gt;다음 그림을 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/60555911-cf895b80-9d79-11e9-94e4-e8bb3165c034.png&quot; width=&quot;80%&quot; height=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왼쪽 그림은 앞서 본 것처럼 테이블 전체에다 Lock을 걸어 놓은 것입니다. Coarse Grain Locking이라고 하는데요. 테이블 전체에다 Lock을 걸어 놓은 것이라 Alice와 Bob이 테이블의 다른 항목(A,B)에 접근하려는 경우에도 Alice나 Bob 둘 중 한 스레드가 테이블을 독점하는 비효율이 발생하게 됩니다.
이에 대한 해결책으로 테이블을 더 잘게 항목별로 나눠서 각 항목마다 Lock을 걸어주는 방법이 있습니다. Fine Grain Locking이라 부르고 오른쪽 그림과 같은 상황을 얘기하는 것입니다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Coarse Grain Locking의 장점은 사용하기 쉽다는 것이고, 단점은 성능이 떨어진다는 것입니다. Fine Grain Locking은 그 반대라고 보시면 되겠죠.&lt;/p&gt;

&lt;p&gt;Intel TSX는 바로 이 지점에서 솔루션을 제시합니다. 개발자들이 Coarse Grain Locking을 걸어놓으면 하드웨어 레벨에서 Fine Grain Locking 처리를 해주는 것입니다.
&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/60556606-247aa100-9d7d-11e9-85e0-b03fcb2405c6.png&quot; width=&quot;80%&quot; height=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;바로 “Fine Grain Behavior at Coarse Grain Effort”라는 목표를 위해 개발된 기술이 Intel TSX 라는 것입니다. 결국 개발자의 편의성과 성능 2가지 토끼를 다 잡겠다는 얘기입니다.&lt;/p&gt;

&lt;p&gt;그럼 이 기술을 개발자가 어떻게 쓰나요? &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음 그림처럼 크리티컬섹션(공유자원에 접근하는 코드영역)에 Lock을 걸어주면 됩니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xacquire lock mov [rax], 1          ; lock을 획득합니다.
...
...         ; 크리티컬 섹션(트랜잭션 리전)
...
xrelease lock mov [rax], 0          ; lock을 해제하려면 원래 값(0)으로 복원해줘야 합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Lock을 걸려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;xacquire&lt;/code&gt;, 해제할 경우엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;xrelease&lt;/code&gt;라는 명령어를 사용하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Transactional Memory&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xacquire&lt;/code&gt;을 통해 크리티컬 섹션(TSX에선 트랜잭션 리전이라고도 부름)에 진입하면, 트랜잭션 실행(Transactional Execution) 상태로 바뀝니다. 이 시점부터 이루어지는 메모리 업데이트(Transactional Update)는 트랜잭션 메모리(Transactional Memory)라는 곳에 기록됩니다. 다른 스레드가 이 시점에선 해당 업데이트된 내용을 확인할 수 없습니다. 트랜잭션이 완료되기 전까지는요. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xrelease&lt;/code&gt;를 통해 트랜잭션 리전을 빠져나올 때 데이터 충돌(data conflict)이 없다고 판단이 되면 트랜잭션을 완료하게 됩니다. 즉 트랜잭션 메모리에서 기록했던 변경사항들을 실제 메인 메모리에 반영(Transactional Commit)합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hotel California’s Sandbox&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;올해 2019년 Defcon CTF에서 출제된 ‘Hotel California’ 문제는 Intel TSX의 &lt;code class=&quot;highlighter-rouge&quot;&gt;xacquire&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;xrelease&lt;/code&gt; 명령어를 이용해서 샌드박스를 구현했습니다.&lt;/p&gt;

&lt;p&gt;스레드가 크리티컬섹션(트랜잭션 리전)에 진입하면,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;메모리 write 명령이 실제 메인메모리에 반영되지 않고, 트랜잭션메모리에 쓰여짐&lt;/li&gt;
  &lt;li&gt;스레드의 시스템 콜 호출이 허용되지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 사실을 통해 샌드박스를 다음과 같이 구현했습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mov [rdi], eax       ; eax = key_X, ebx = key_Y
xor eax, rax         ; key_X 지움

xacquire lock xor [rdi], ebx  ;  트랜잭션 리전 진입,  key_Z = key_X xor key_Y

xor rbx, rbx         ; key_Y 지움

[유저 쉘코드 시작]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 샌드박스 환경에서 참가자가 작성한 쉘코드가 실행되는 챌린지입니다.  쉘코드에서 시스템 콜을 호출하고 싶은데, 샌드박스라 호출할 수가 없습니다.&lt;/p&gt;

&lt;p&gt;만약 key_X를 알수만 있다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;xrelease&lt;/code&gt;를 사용해 lock을 풀고 트랜잭션 상태를 빠져나오게 되어 샌드박스를 탈출할 수 있습니다.&lt;/p&gt;

&lt;p&gt;쉘코드에서 key_X를 알 수 있을까요?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU Bug?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pwn2Own 우승팀(Safari 카테고리)으로도 유명한 ret2system에서 위 문제를 풀다가 Intel TSX에서 버그를 발견합니다. 해당 버그를 이용해 문제를 해결하였는데요.&lt;/p&gt;

&lt;p&gt;우선 쉘코드와 lock(문제에서 rdi가 가리키는 곳)이 같은 rwx 페이지에 있었기 때문에, CPU의 명령어 cache에 key_X가 존재할 것이라는 가정을 합니다. 이 상황에서 트랜잭션 리전에 진입을 하게 되고, lock은 리전에 진입할 때 key_Z(key_X xor key_Y)로 바뀌죠.&lt;/p&gt;

&lt;p&gt;여기서 만약 lock으로 jmp를 하면 어떻게 될까요?
&lt;br /&gt;&lt;br /&gt;
원래라면 명령어 cache에 있는 내용(key_X)과 트랜잭션 메모리에 있는 내용(key_Z)의 불일치 현상이 발생했기 때문에, 트랜잭션 메모리에 있는 내용으로 명령어 cache를 업데이트 해주고, 그것(key_Z)을 fetch하여 실행해야 할 것입니다.&lt;/p&gt;

&lt;p&gt;하지만, 이러한 &lt;u&gt;명령어cache와 트랜잭션 메모리간의 불일치 현상이 존재함에도 불구하고, 명령어cache에서 fetch 해올 때 이러한 불일치 현상을 체크하지 않는 버그&lt;/u&gt;가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://blog.ret2.io/assets/img/tsx_jmp_key_z.png&quot; alt=&quot;ret2system blog&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그래서 lock으로 jmp를 하게 되면 key_Z를 실행하는 대신, 명령어 cache에 있던 (key_X)를 실행하게 되는 것입니다!&lt;/p&gt;

&lt;p&gt;key_X를 읽는 것이 아닌, key_X를 실행할 수 있게 되었습니다. key_X는 랜덤한 값이라 어떤 명령어 코드가 들어있을 지 예측할 수가 없죠. 
그래서 ret2system은 key_X가 다음 opcode 조합이 나올 때까지 Bruteforce를 했습니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C2 xx xx 90     ; retn xx xx; nop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;앞 C2 뒤 90만 맞으면 되기 때문에, 대략 65536 번 안에는 해당 바이트 시퀀스 조합이 나올 확률이 높습니다.
만약 저 패턴의 명령어(retn xx xx; nop)가 실행되면 rsp 값을 계산해서 xx xx 값을 얻어낼 수가 있을 것입니다. 
결국 key_X 값을 구할 수 있게 되는 것이죠.&lt;/p&gt;

&lt;p&gt;결론:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ret2system에서 Defcon CTF 문제를 풀다가 Intel TSX에서 CPU 버그를 발견&lt;/li&gt;
  &lt;li&gt;Intel TSX에서 명령어cache와 트랜잭션 메모리간의 불일치 현상 버그&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Defcon CTF 문제 설명과 풀이에 대한 자세한 내용은 ret2system blog를 참고해주세요.&lt;/p&gt;

&lt;h4 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.ret2.io/2019/06/26/attacking-intel-tsx/&quot;&gt;In Transactional Memory, No One Can Hear You Scream&lt;/a&gt;, ret2system blog&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/blogs/2013/07/25/fun-with-intel-transactional-synchronization-extensions&quot;&gt;Fun with Intel® Transactional Synchronization Extensions&lt;/a&gt;, Intel Developer Zone&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://software.intel.com/sites/default/files/managed/68/10/sf12-arcs004-100.pdf&quot;&gt;Intel® Transactional Synchronization Extensions&lt;/a&gt;, Intel Developer Forum 2012&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Transactional_Synchronization_Extensions&quot;&gt;Transactional Synchronization Extensions&lt;/a&gt;, Wikipedia&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/blogs/2012/02/07/transactional-synchronization-in-haswell&quot;&gt;Transactional Synchronization in Haswell&lt;/a&gt;, Intel Developer Zone&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/blogs/2012/02/07/coarse-grained-locks-and-transactional-synchronization-explained&quot;&gt;Coarse-grained locks and Transactional Synchronization explained&lt;/a&gt;, Intel Developer Zone&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-return-of-the-wizard-cve-2019-10149&quot;&gt;&lt;a href=&quot;https://www.openwall.com/lists/oss-security/2019/06/06/1&quot;&gt;The Return of the WIZard (CVE-2019-10149)&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;인터넷 메일 서버 Exim의 원격 취약점이 Qualys Security의 한 연구원에 의해 6월 6일에 공개되었습니다. 
&lt;br /&gt;&lt;br /&gt;
2019년 6월 기준으로 전체 메일서버의 57%에서 Exim을 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/60494147-33177880-9ce9-11e9-88ea-4c06f4da771c.png&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;a href=&quot;http://www.securityspace.com/s_survey/data/man.201905/mxsurvey.html&quot;&gt;Mail (MX) Server Survey&lt;/a&gt;&lt;/center&gt;

&lt;p&gt;당장 수십만대의 서버가 해킹에 당할 가능성이 생긴 것이죠.&lt;/p&gt;

&lt;p&gt;영향을 받는 Exim 버전은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Exim 메일서버 4.87~4.91 버전&lt;/li&gt;
  &lt;li&gt;취약점은 이미 19년 2월 10일에 패치되었으나, Security 취약점으로 분류되지 않아 대부분의 OS가 영향을 받음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;관리 중인 Exim서버가 위 영향 범위에 포함되어 있다면 최신 패치를 적용해야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;취약점-상세&quot;&gt;취약점 상세&lt;/h4&gt;

&lt;p&gt;취약점은 로컬 및 원격에서 공격 가능한 논리 취약점(커맨드 인젝션)입니다.&lt;/p&gt;

&lt;p&gt;로컬 공격은 수신자의 메일 주소를 &lt;code class=&quot;highlighter-rouge&quot;&gt;${run{\&amp;lt;command&amp;gt; \&amp;lt;args&amp;gt;}&lt;/code&gt; 와 같이 설정하면 &lt;em&gt;command&lt;/em&gt; 부분이 실행되는 방식입니다. 보통 root권한으로 Exim이 실행되기 때문에 root 권한상승 공격으로 이어질 수 있습니다.&lt;/p&gt;

&lt;p&gt;원격 공격은 취약한 코드로 도달하기까지 몇 가지 조건들을 통과해야 합니다.&lt;br /&gt;
공격 과정을 요약하면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;1) 취약한 Exim 서버에 메일 전송 요청을 보낼 때 “발신자 주소”에 명령어를 포함시키고 “수신자 주소”는 도달할 수 없는 주소로 설정합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;예) 발신자 주소: ${run{&amp;lt;command&amp;gt; &amp;lt;args&amp;gt;}}@example.com&lt;/li&gt;
  &lt;li&gt;example.com은 공격자가 컨트롤 가능한 메일서버여야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2) Exim 서버는 수신자 주소로 메일을 전달할 수 없으므로, 발신자에게 메일을 전송할 수 없다는 &lt;em&gt;Bounce&lt;/em&gt; 메시지를 전송합니다.&lt;/p&gt;

&lt;p&gt;3) 공격자는 Exim 으로 부터 온 연결을 최소 7일간 유지해야 합니다.(매 4분마다 Exim 서버로 1byte 전송)&lt;/p&gt;

&lt;p&gt;4) 7일 이후 전송실패 응답을 Exim 서버에 전달하면, 발신자 주소에 포함되어 있던 명령어가 실행됩니다.&lt;/p&gt;

&lt;p&gt;더 자세한 내용은 원문을 포함한 아래 참고 자료를 참고해주세요.&lt;/p&gt;

&lt;h4 id=&quot;참고&quot;&gt;참고&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.openwall.com/lists/oss-security/2019/06/06/1&quot;&gt;The Return of the WIZard: RCE in Exim (CVE-2019-10149), Qualys Security Advisory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zdnet.com/article/exim-email-servers-are-now-under-attack/&quot;&gt;Exim email servers are now under attack, ZDNet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 02 Jul 2019 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>DIFF-2019-001</title>
        <link>/2019/06/24/Weekly-Diffense.html</link>
        <guid isPermaLink="true">/2019/06/24/Weekly-Diffense.html</guid>
        <description>&lt;hr /&gt;

&lt;h1 id=&quot;issues&quot;&gt;Issues&lt;/h1&gt;

&lt;h3 id=&quot;coinbase-암호화폐-거래소-해킹-공격&quot;&gt;Coinbase 암호화폐 거래소 해킹 공격&lt;/h3&gt;

&lt;p&gt;6월 19일, Coinbase라는 암호화폐 거래소에서 보안 담당자로 일하는 Philip Martin이란 사람이 트윗(&lt;a href=&quot;https://twitter.com/SecurityGuyPhil/status/1141466335592869888&quot;&gt;https://twitter.com/SecurityGuyPhil/status/1141466335592869888&lt;/a&gt;)을 하나 올립니다.
&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/60066734-068cbb00-9743-11e9-807a-e6c559f2ec39.png&quot; alt=&quot;&quot; /&gt;
6월 17일 월요일에 자기 회사 직원들의 PC를 대상으로 파이어폭스 0day가 포함된 해킹 공격이 시도된 것을 탐지하여 차단했다는 내용입니다. 지난 주 꽤 큰 이슈가 되었습니다. 아무래도 거래소는 돈과 관련이 있으니까요.&lt;/p&gt;

&lt;p&gt;해킹에 사용된 취약점은 Firefox 원격코드실행 취약점(CVE-2019-11707)과 샌드박스탈출 취약점(CVE-2019-11708) 2종이 사용되었습니다. Coinbase는 공격체인에 사용된 2개의 취약점을 Mozilla에 보고하게 됩니다. 흥미로운 부분은 취약점 중 하나가 Google Project Zero팀의 Saelo가 이미 보고(4월15일)한 것과 동일하였다는 점입니다. 어떻게 해커들은 해당 취약점 정보를 입수할 수 있었을까요? 해커들이 직접 발견했을 수도 있고, 모질라 버그이슈 트래커 접근 권한을 가지고 있었을 수도 있겠죠. 여러가지 썰들이 나오고 있는 상황입니다.&lt;/p&gt;

&lt;p&gt;해킹 방식은 타겟팅된 직원들 대상으로 피싱 이메일을 보내 첨부된 링크를 클릭하면 Firefox 취약점이 발동하는 식으로 동작합니다. 공격이 성공하면 최종적으로 RAT(원격 관리 툴)이 PC에 설치됩니다.&lt;/p&gt;

&lt;p&gt;RAT는 Win/Mac 용으로 제작되어 있다고 하네요. Mac용 백도어는 이 곳(&lt;a href=&quot;https://objective-see.com/blog/blog_0x43.html&quot;&gt;https://objective-see.com/&lt;/a&gt;)에서 분석을 잘해놓았습니다. 다운로드도 가능합니다. 분석용도로만 보시기 바랍니다. 여기서 분석한 내용을 요약해드리면 다음과 같습니다. (자세한 내용은 해당사이트 참조)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이 악성코드(OSX.Netwire)는 바이러스토탈에서 Tencent 만 탐지하였음&lt;/li&gt;
  &lt;li&gt;2012년에 Dr.Web에 처음으로 탐지되었는데 리눅스,Mac 대상으로 패스워드를 훔치는 최초의 악성코드라고 함&lt;/li&gt;
  &lt;li&gt;패스워드는 키로깅과 디스크내 파일을 통해 훔침&lt;/li&gt;
  &lt;li&gt;2012년 샘플과 2019년 것은 유사한 부분도 있지만 매우 다르기도 함. 추측해보건데 같은 개발자가 개발한 것 같지만 악성코드의 목적이 완전히 다른 것 같다며 악성코드 분석 내용을 게재할 예정이라 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;거래소 직원 PC를 해킹하는 목적은 최종적으로 거래소 전산 시스템에 접근하여 코인을 탈취하려는 것입니다. 우리는 이미 국내에서 발생한 은행/거래소 해킹 사례를 통해, 내부 직원 PC가 뚫리면 더 큰 사고로 이어질 수 있음을 경험했습니다. 가상 화폐 거래소를 대상으로 하는 공격이 지속적으로 이루어지고 있으므로, 거래소의 보안 인식 및 기술수준이 더욱 높아져야 할 것입니다.&lt;/p&gt;

&lt;p&gt;참고링크:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bleepingcomputer.com/news/security/firefox-0-day-used-in-targeted-attacks-against-cryptocurrency-firms/&quot;&gt;Firefox 0-day Used in Targeted Attacks Against Cryptocurrency Firms&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://objective-see.com/blog/blog_0x43.html&quot;&gt;Burned by Fire(fox)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/SecurityGuyPhil/status/1141466335592869888&quot;&gt;Martin’s a Tweet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;rdp-bluekeepcve-2019-0708&quot;&gt;RDP BlueKeep(CVE-2019-0708)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/60060521-fa493380-972b-11e9-9f92-8ba9273f04e5.png&quot; alt=&quot;Micrsoft Security Updates&quot; /&gt;
5월 14일, RDP(Remote Desktop Services) 서버 취약점에 대한 &lt;a href=&quot;https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2019-0708&quot;&gt;패치&lt;/a&gt;가 릴리즈되었습니다.&lt;/p&gt;

&lt;p&gt;이 사실은 엄청난 파장을 일으켰습니다. 왜냐하면 해당 버그는 &lt;u&gt;인증 과정 필요없이 RDP서버를 원격에서 해킹할 수 있는 취약점이라서, 이 공격에 영향을 받는 컴퓨터가 대략 수 백만대&lt;/u&gt;로 추정되었기 때문이죠. Windows8 이전의 운영체제(WinXP, 7, 2008등)가 모두 이 취약점에 영향을 받습니다.&lt;/p&gt;

&lt;p&gt;초기에는 가짜 PoC들이 Github에 올라왔었고, 심지어 cve-2019-0708.com에서 가짜 익스플로잇을 판매하기도 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/60064826-9da24480-973c-11e9-93dd-6bbe736892a7.png&quot; alt=&quot;Fake Exploit&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이후 여러 분석가들 및 보안회사들에서 분석 내용을 공유하였습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;McAfee, &lt;a href=&quot;https://securingtomorrow.mcafee.com/other-blogs/mcafee-labs/rdp-stands-for-really-do-patch-understanding-the-wormable-rdp-vulnerability-cve-2019-0708/&quot;&gt;RDP Stands for “Really DO Patch!” – Understanding the Wormable RDP Vulnerability CVE-2019-0708&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;ZDI, &lt;a href=&quot;https://www.zerodayinitiative.com/blog/2019/5/27/cve-2019-0708-a-comprehensive-analysis-of-a-remote-desktop-services-vulnerability&quot;&gt;CVE-2019-0708: A COMPREHENSIVE ANALYSIS OF A REMOTE DESKTOP SERVICES VULNERABILITY&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;MalwareTech, &lt;a href=&quot;https://www.malwaretech.com/2019/05/analysis-of-cve-2019-0708-bluekeep.html&quot;&gt;Analysis of CVE-2019-0708 (BlueKeep)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;커널(termdd.sys)에서 발생하는 UAF(Use-After-Free) 취약점으로 자세한 내용은 위 링크를 참조해주세요.&lt;/p&gt;

&lt;p&gt;취약점 스캐너도 여럿 공개된 상황입니다. Qihoo360에서 웹기반 스캐너를 먼저 공개(4월19일)하였고, 이 후 zerosum0x0(eternalblue 분석으로도 유명한)이라는 리서쳐도 공개(4월22일)하였습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/mj0011sec/status/1130387741538054144&quot;&gt;CVE-2019-0708 remote scan tool by 360Vulcan team&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;일반인에게는 공개하지 않은 것 같고, 360 에 메일 문의를 해야 스캐닝 서비스를 받을 수 있는 것으로 보이네요.
&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/60062762-7bf18f00-9735-11e9-9bb0-0d31df976fa8.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;zerosum0x0 Github, &lt;a href=&quot;https://github.com/zerosum0x0/CVE-2019-0708&quot;&gt;Scanner PoC for CVE-2019-0708 RDP RCE vuln&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;rdesktop를 수정하여 만든 스캐너입니다. github 에서 받아 테스트해볼 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Qihoo360, McAfee, Theori 등의 보안 회사에서 익스플로잇 데모 동영상을 공개하였으나 익스플로잇 개발과 관련된 민감한 내용은 인류평화(?)를 위해 공개하지 않고 있습니다. 관련 내용이 공개되는 순간 여러 해킹 툴킷에 탑재될 것이 자명하고, 많은 수의 컴퓨터가 위험에 노출될 것이니까요.&lt;/p&gt;

&lt;p&gt;패치가 릴리즈되고 나서 한달이 지난 지금에도 수십만대의 PC가 여전히 패치되지 않고 취약점에 노출되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/50191798/60063263-48176900-9737-11e9-8291-43486f8bb234.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;EternalBlue가 Shadow Broker에 의해 공개(2017년 4월)된 이후 한달여만에 WannaCry(2017년 5월)가 그것을 탑재하였듯이, 머지않아 BlueKeep 익스플로잇이 대규모 공격에 사용되는 날이 올 것입니다.&lt;/p&gt;

&lt;p&gt;RDP를 사용하는 분(Pre-Windows8 사용자)들은 꼭 패치해주세요.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;vulnerabilities&quot;&gt;Vulnerabilities&lt;/h1&gt;

&lt;h3 id=&quot;cve-2019-1064-appxsvc-local-privilege-escalation&quot;&gt;&lt;a href=&quot;https://www.rythmstick.net/posts/cve-2019-1064/&quot;&gt;CVE-2019-1064 AppXSVC Local Privilege Escalation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;SandboxEscaper가 2019년 6월에 공개한 &lt;em&gt;Windows AppX Deployment Service(AppXSVC)&lt;/em&gt; 권한상승 0-day 에 대한 내용입니다. 해당 취약점은 6월 패치에 포함되었습니다. 요약하면,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AppData\Local\Packages의 서브 폴더(예:LocalState)가 제거되면, AppXSVC가 해당 폴더를 다시 생성함&lt;/li&gt;
  &lt;li&gt;&lt;u&gt;LocalState 폴더가 다시 생성될 때, 해당 폴더내의 파일 DACL이 변경됨&lt;/u&gt;(일반사용자가 Full Control을 가지도록)&lt;/li&gt;
  &lt;li&gt;Race Condition을 이용하면 임의 파일의 DACL을 변경할 수 있음&lt;/li&gt;
  &lt;li&gt;익스플로잇 과정
    &lt;ul&gt;
      &lt;li&gt;LocalState 폴더를 제거하고서, 다시 생성되는 시점까지 대기&lt;/li&gt;
      &lt;li&gt;익스플로잇에서 해당 폴더 밑에 파일(rs.txt)을 생성하고 임의 파일(예: c:\windows\system.ini)로 Hardlink를 걸어둠&lt;/li&gt;
      &lt;li&gt;AppXSVC는 system.ini의 DACL을 변경하여 일반 사용자에게 Full Control 권한 부여함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;techniques&quot;&gt;Techniques&lt;/h1&gt;

&lt;h3 id=&quot;heap-overflow-exploitation-on-windows-10-explained&quot;&gt;&lt;a href=&quot;https://blog.rapid7.com/2019/06/12/heap-overflow-exploitation-on-windows-10-explained/&quot;&gt;“Heap Overflow Exploitation on Windows 10 Explained”&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Corelan의 이전 멤버였던 Wei Chen이란 분이 Windows 10 힙 오버플로우 익스플로잇 방법을 기술한 글입니다. Win10에서는 어떤 차이가 있는지 도움이 되는 글입니다. 요약하면,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;힙 오버플로우 성공하기 위해선, 메모리청크들을 원하는 위치에 배치할 수 있어야 하고 그들간의 오프셋이 얼마인지 예측할 수 있어야 합니다.&lt;/li&gt;
  &lt;li&gt;동일한 크기의 힙청크를 연속적으로 할당할 때, Win7에서는 메모리 청크간의 오프셋이 일정하지만 Win10에서는 그것이 랜덤합니다. 하지만 항상 랜덤은 아니고, &lt;u&gt;LFH가 활성화 되기전에는 청크간의 오프셋이 고정적이란 사실을 이용&lt;/u&gt;해서, LFH가 활성화되기 전에 힙 레이아웃을 맞춰놓고 오버플로우해야 한다고 설명합니다.&lt;/li&gt;
  &lt;li&gt;BSTR 문자열 객체를 이용해 메모리릭 예제를 보여줍니다. Vector 객체를 이용해 코드실행 예제를 보여줍니다.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 24 Jun 2019 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Better than spoolsv</title>
        <link>/2019/03/04/Better-than-spoolsv.html</link>
        <guid isPermaLink="true">/2019/03/04/Better-than-spoolsv.html</guid>
        <description>&lt;p&gt;안녕하세요. 디펜스입니다.&lt;/p&gt;

&lt;p&gt;이전 글(&lt;a href=&quot;http://blog.diffense.co.kr/2019/02/22/hard-link/&quot;&gt;Windows HardLink Attack &amp;amp; Defense&lt;/a&gt;)에서 우리는 &lt;em&gt;sandboxescaper&lt;/em&gt;의 익스플로잇이 &lt;em&gt;스풀러 서비스(Spoolsv)&lt;/em&gt;를 통해서 최종적으로 페이로드를 실행한다는 점을 살펴보았습니다. 복습하는 차원에서 그 과정을 단순화해보면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/DHub/spooler_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;태스크스케쥴러 서비스 취약점 호출(DACL 변경 취약점)&lt;/li&gt;
  &lt;li&gt;취약점을 이용해 PrintConfig.dll 파일 쓰기 권한 획득&lt;/li&gt;
  &lt;li&gt;PrintConfig.dll을 페이로드로 덮어씀&lt;/li&gt;
  &lt;li&gt;스풀러 서비스 호출&lt;/li&gt;
  &lt;li&gt;스풀러 서비스를 통해 페이로드 실행(시스템 권한)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여기서 취약점 트리거(~2번)는 성공했는데 3~5번 과정에서 실패하는 경우가 있을까요? 즉 취약점은 잘 동작하였으나, 스풀러 서비스로 페이로드를 올리는 과정(3~5번)이 실패하는 경우 말이죠. 만약 3~5번 과정이 실패하면 페이로드를 시스템 권한에서 실행시킬 수 있는 다른 방법을 모색해봐야 할 것입니다.&lt;/p&gt;

&lt;p&gt;이번 글의 주제는 3~5번 과정이 실패할 수 있는 상황에서 스풀러 서비스 대신 &lt;em&gt;페이로드를 시스템 권한으로 실행할 수 있는 다른 방법&lt;/em&gt;을 알아보는 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;windows-eop-0-day&quot;&gt;Windows EoP 0-day&lt;/h3&gt;

&lt;p&gt;저희가 연구 목적으로 개발한 &lt;em&gt;윈도우즈 권한상승(EoP) 0-day&lt;/em&gt;는 다음과 같이 동작합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/DHub/our_eop.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;‘음? 앞선 그림이랑 똑같은거 아닌가요?’ 네 맞습니다. sandboxescaper 익스플로잇과 비슷하게 동작합니다. 차이점이라면 스케쥴러 서비스가 아닌 다른 시스템 서비스에 취약점이 존재한다는 점입니다. 설명을 위해 다음 2가지 사실만 알고 있으면 됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;해당 취약점을 이용하면 임의 파일의 DACL을 변경할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;시스템 권한의 페이로드를 실행하기 위해 sandboxescaper가 사용한 스풀러 서비스 방식(3~5번 과정)을 그대로 차용했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;printconfigdll-사용중&quot;&gt;PrintConfig.dll 사용중?&lt;/h3&gt;

&lt;p&gt;취약점 연구 조직들은 정기적인 시큐리티 업데이트(예:Patch Tuesday&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;)에 맞춰 자신들이 가지고 있는 취약점을 테스트합니다. ‘취약점이 패치되었는지? 패치되었다면 어떤 식으로?’ 등을 확인하는 목적이지요.&lt;/p&gt;

&lt;p&gt;저희 역시 그러한 테스트를 진행하던 중에 저희 EoP PoC가 미동작하는 상황을 발견하게 되었습니다. 그럼 미동작 원인을 분석해 보아야 하겠죠? 같이 한번 살펴보도록 해요.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;취약점은 살아있는가?
    &lt;ul&gt;
      &lt;li&gt;위 그림에서 1~2번 단계가 제대로 실행되는지 확인을 해보면 취약점 패치 여부를 알 수 있을 것입니다.&lt;/li&gt;
      &lt;li&gt;PoC를 실행하고서, PrintConfig.dll의 DACL이 변경되었는지를 살펴보았습니다. 
&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/DHub/PrintConfig_after.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;빨간색 박스를 보면 Users가 PrintConfig.dll에 대한 모든 권한(Full)을 가지고 있는 것을 확인할 수 있습니다. DACL이 변경된 것을 확인하였고, 따라서 &lt;em&gt;취약점은 패치되지 않은 채 여전히 존재&lt;/em&gt;한다고 볼 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PrintConfig.dll은 페이로드로 교체되었나?
    &lt;ul&gt;
      &lt;li&gt;확인을 해보니 PrintConfig.dll이 페이로드로 교체되지 않았습니다. 쓰기 권한은 있는데 쓸 수가 없다? 무슨 문제일까요?&lt;/li&gt;
      &lt;li&gt;문제의 원인은 다음 그림을 보면 알 수 있습니다.
&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/DHub/PrintConfig.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;바로 spoolsv.exe에서 PrintConfig.dll을 사용하고 있었던 것이죠.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;spoolsv.exe가 DriverStore\PrintConfig.dll을 사용하는 경우가 있었습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PrintConfig.dll&lt;/code&gt;이 스풀러에 의해 이미 사용되고 있어, &lt;code class=&quot;highlighter-rouge&quot;&gt;Users&lt;/code&gt;에게 모든 권한(쓰기포함)이 주어졌음에도 해당 파일을 덮어쓸 수 없는 상황이었던 것이죠.&lt;/p&gt;

&lt;h3 id=&quot;another-option&quot;&gt;Another option?&lt;/h3&gt;

&lt;p&gt;스풀러 서비스를 통해 페이로드를 실행시키는 방법이 실패할 수 있는 케이스를 알아보았습니다.&lt;/p&gt;

&lt;p&gt;그럼 이제 대안이 필요한 상황이군요. 즉 취약점을 이용해 임의의 파일을 쓰기 가능 상태로 만들 수 있는 경우(2번 단계까지 가능한 경우), 스풀러 서비스 방법 대신 페이로드를 실행시킬 수 있는 다른 방법은 어떤 것이 있을까요?&lt;/p&gt;

&lt;h3 id=&quot;diagnostics-hub-standard-collector&quot;&gt;Diagnostics Hub Standard Collector&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Diagnostics Hub Standard Collector 서비스(줄여서 D-Hub)&lt;/em&gt;는 시스템 권한으로 돌아가는 윈도우즈 서비스입니다. 우리는 스풀러 대신 이 서비스를 활용해 볼 것입니다.&lt;/p&gt;

&lt;p&gt;이 서비스의 존재를 알게 된 계기는 천재 해커인 Lokihardt(구글 프로젝트 제로)가 Pwn2Own 2016을 통해 해당 서비스의 취약점 &lt;code class=&quot;highlighter-rouge&quot;&gt;CVE-2016-3231&lt;/code&gt;을 공개하고 나서인데요. 취약점을 우선 간단히 설명하고, 이 서비스를 어떻게 활용할 수 있는 지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;D-Hub는 &lt;code class=&quot;highlighter-rouge&quot;&gt;AddAgent&lt;/code&gt;라는 API를 사용자(클라이언트)에게 제공합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/DHub/DHub_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;D-Hub의 &lt;code class=&quot;highlighter-rouge&quot;&gt;AddAgent&lt;/code&gt;를 호출할 때 인자로 DLL 파일명을 같이 넘겨주면, D-Hub는 그 파일명을 받아서 &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadLibrary&lt;/code&gt;(DLL 로드하는 함수)의 인자로 넘겨주는 것이죠. 결국 사용자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;AddAgent&lt;/code&gt;를 통해 D-Hub가 로드할 Dll을 지정할 수 있는 것입니다.&lt;/p&gt;

&lt;p&gt;Lokihardt는 이 부분에서 아래 그림처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;Directory Traversal&lt;/code&gt; 취약점을 발견하여 Edge 샌드박스 탈출에 성공했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/DHub/DHub_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 취약점은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Directory Traversal&lt;/code&gt;이 발생하지 않도록 패치가 되었습니다.&lt;/p&gt;

&lt;p&gt;우리가 지금 관심있는 것은 취약점이 아니라, 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;AddAgent&lt;/code&gt;라는 기능입니다. 이 기능을 이용하면 &lt;em&gt;System32 폴더에 있는 DLL을 D-Hub 서비스(시스템권한)로 로드할 수 있기 때문&lt;/em&gt;이죠. (정확히 말하면 DLL Search Order&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;로 정해진 폴더 순으로 DLL을 검색합니다. 설명의 편의를 위해 System32 폴더를 예로 들겠습니다.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AddAgent를 이용하면 System32 폴더에 있는 DLL을 D-Hub 서비스(시스템권한)로 로드할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;밝힘)
&lt;em&gt;D-Hub 기능을 활용할 수 있을 지 조사를 하던 중, James Forshaw가 이미 관련 내용&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;을 자세히 공개한 것을 확인할 수 있었습니다. 좋은 발표 많이 해주는 James Forshaw에게 다시 한번 감사!&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;d-hub-방식의-장점&quot;&gt;D-Hub 방식의 장점?&lt;/h3&gt;

&lt;p&gt;D-Hub를 이용하는 방식은 스풀러에 비해 어떤 장점이 있을까요?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;D-Hub를 이용하면 System32에 있는 많은 DLL 중에서 사용중이지 않은 DLL을 선택해서 로드할 수 있다는 장점이 있습니다. PrintConfig.dll이 사용 중인 경우에는 스풀러를 이용하지 못하는 반면, D-Hub를 이용하면 수많은 DLL 중 하나를 선택해서 로드시킬 수 있다는 장점이 있는 것이죠.
&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/DHub/DHub_Better.png&quot; alt=&quot;&quot; /&gt;
    &lt;blockquote&gt;
      &lt;p&gt;D-Hub를 이용하면 사용 중이지 않은 DLL을 선택해서 로드시킬 수 있어요.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;스풀러를 이용하려면 PrintConfig.dll의 경로를 확인하는 과정이 필요하다는 단점이 있습니다. PrintConfig.dll 경로가 고정적이지 않기 때문이예요. 참고로 sandboxescaper는 PrintConfig.dll 경로를 구하기 위해 다음과 같은 코드&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;를 작성했습니다.
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;WIN32_FIND_DATA&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FindFileData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hFind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hFind&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FindFirstFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;L&quot;C:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Windows&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;System32&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;DriverStore&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;FileRepository&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;prnms003.inf_amd64*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FindFileData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BeginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_PATH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;c:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;windows&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;system32&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;DriverStore&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;FileRepository&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrinterDriverFolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_PATH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EndPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Amd64&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;PrintConfig.dll&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;wmemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PrinterDriverFolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FindFileData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wcslen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FindFileData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FindClose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hFind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;wcscat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BeginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrinterDriverFolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;wcscat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BeginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EndPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;D-Hub 방식은 이런 과정이 필요 없습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;demo&quot;&gt;Demo&lt;/h3&gt;

&lt;p&gt;D-Hub 방식을 적용한 후 EoP 0-day의 동작 테스트를 진행해보았습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/embed/cBIXxn85oLM&quot;&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/DHub/video.png&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;동영상 데모의 단계별 설명입니다. 
(페이로드로 덮어쓸 파일은 &lt;code class=&quot;highlighter-rouge&quot;&gt;System32\CIRCoInst.dll&lt;/code&gt;을 선택했습니다.)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;최신 업데이트(2019-02-28 업데이트)임을 확인합니다.&lt;/li&gt;
  &lt;li&gt;whoami를 이용해 현재 사용자(관리자 아님)를 확인합니다.&lt;/li&gt;
  &lt;li&gt;c:\windows\system32\whoami.txt 에 파일이 존재하지 않음을 확인합니다.&lt;/li&gt;
  &lt;li&gt;icacls 명령을 이용해 c:\windows\system32\CIRCoInst.dll 파일의 DACL을 확인합니다.
    &lt;ul&gt;
      &lt;li&gt;Users 그룹을 확인해 주세요.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PoC를 실행합니다.&lt;/li&gt;
  &lt;li&gt;실행이 끝나면 CIRCoInst.dll의 DACL을 다시 한번 확인합니다.
    &lt;ul&gt;
      &lt;li&gt;Users 그룹이 모든 권한(Full)을 가지도록 변경되었는지 확인합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Process Explorer를 실행하여, D-Hub 프로세스(DiagnosticsHub.StandardCollector.Service.exe)가 실행되었는지 확인합니다.&lt;/li&gt;
  &lt;li&gt;D-Hub 프로세스를 통해 페이로드가 실행되었는지 확인합니다.
    &lt;ul&gt;
      &lt;li&gt;페이로드는 whoami &amp;gt; c:\windows\system32\whoami.txt 를 실행하도록 되어 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;c:\windows\system32\whoami.txt 내용을 열어 System인지 확인합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;마치며&quot;&gt;마치며&lt;/h3&gt;

&lt;p&gt;취약점 연구를 하는 목적은 분명합니다. 해킹 공격을 효과적으로 탐지하고 차단할 수 있는 기술 개발에 이러한 취약점 연구가 기반이 된다고 믿습니다. 디펜스는 연구 산출물을 고객에게 우선적으로 제공하여 최신 해킹 위협에 대응할 수 있도록 도움을 드리고 있습니다.&lt;/p&gt;

&lt;p&gt;감사합니다. 다음 번 블로그에서 뵙겠습니다!&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Patch Tuesday, https://en.wikipedia.org/wiki/Patch_Tuesday &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;Dynamic-Link Library Search Order, https://docs.microsoft.com/en-us/windows/desktop/dlls/dynamic-link-library-search-order &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;Windows Exploitation Tricks: Exploiting Arbitrary File Writes for Local Elevation of Privilege, https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;https://github.com/jackson5-sec/TaskSchedLPE/blob/master/Original/ALPC-TaskSched-LPE/ALPC-TaskSched-LPE.cpp#L83 &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 04 Mar 2019 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Windows HardLink Attack &amp; Defense</title>
        <link>/2019/02/22/hard-link.html</link>
        <guid isPermaLink="true">/2019/02/22/hard-link.html</guid>
        <description>&lt;p&gt;안녕하세요! 디펜스입니다.&lt;/p&gt;

&lt;p&gt;이번 글에서는 하드링크란 무엇이며, 익스플로잇에서 활용되는 하드링크와 일반적인 하드링크와의 차이점이 무엇인지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;또한, 실제 권한상승 익스플로잇(CVE-2018–8440) 사례를 통해 하드링크가 어떤 식으로 활용되고 있는지 알아봅니다.&lt;/p&gt;

&lt;p&gt;마지막으로 하드링크를 활용한 권한상승 익스플로잇을 효과적으로 탐지할 수 있는 방안에 대해 소개하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;하드링크&quot;&gt;하드링크?&lt;/h3&gt;
&lt;p&gt;(하드링크에 대해 알고 계신 분은 건너뛰세요!)&lt;/p&gt;

&lt;p&gt;윈도우즈 하드링크는 동일한 파일을 참조하는 여러 개의 파일명을 만들 수 있는 기능입니다.&lt;/p&gt;

&lt;p&gt;그림 하나면 쉽게 이해할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Hard_Link_Illustration.svg/314px-Hard_Link_Illustration.svg.png&quot; alt=&quot;hardlink&quot; /&gt; 출처: Wikipedia&lt;/p&gt;

&lt;p&gt;위 그림을 보면 실제 파일이 NTFS 파일시스템 볼륨(C드라이브)내 어딘가에 존재하고 있고, 우리는 이 파일을 A.TXT라는 파일명으로 링크하여 참조하고 있음을 볼 수 있습니다. 하드링크를 이용하면 해당 파일을 참조하는 또 다른 파일명(B.TXT)을 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;만약 하드링크를 통해 파일 내용을 수정하거나 삭제 혹은 권한을 변경하면 어떻게 될까요?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하드링크 수정
    &lt;ul&gt;
      &lt;li&gt;A.TXT, B.TXT는 &lt;em&gt;모두 같은 파일에 대한 링크&lt;/em&gt;라서 둘 중 어떤 링크를 수정하더라도 동일한 결과가 나옵니다.&lt;/li&gt;
      &lt;li&gt;A.TXT를 수정한 다음 B.TXT 내용을 보면 서로 내용이 동일한 것을 알 수 있습니다. 물론 역도 마찬가지입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하드링크 삭제
    &lt;ul&gt;
      &lt;li&gt;파일은 &lt;em&gt;링크 참조 카운트&lt;/em&gt;를 내부적으로 유지하고 있습니다. 예제의 경우 링크 참조 카운트는 2가 될 것입니다.&lt;/li&gt;
      &lt;li&gt;하나의 링크를 삭제하면 그것이 가리키는 파일의 링크 참조카운트가 1씩 감소합니다. 참조카운트가 0이 되면 최종적으로 파일이 삭제됩니다.&lt;/li&gt;
      &lt;li&gt;하나의 링크(A.TXT)를 삭제하더라도 다른 링크(B.TXT)가 살아있다면 해당 파일을 계속 참조할 수 있는 것이죠.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일의 권한을 변경하려는 경우
    &lt;ul&gt;
      &lt;li&gt;기존 링크(A.TXT)나 새로 생성된 하드링크(B.TXT) 둘 중 어떤 링크를 통해 권한을 바꾸어도 둘의 결과는 동일합니다. 링크가 가리키는 파일의 권한이 변경되는 것이죠.&lt;/li&gt;
      &lt;li&gt;탐색기를 열어 A.TXT 파일의 권한을 수정한 후 B.TXT 권한을 확인해보세요. 동일함을 확인할 수 있을 겁니다. 역도 마찬가지입니다.&lt;/li&gt;
      &lt;li&gt;링크 자체의 권한은 어떻게 바꾸는지 궁금한 분들이 있을 것입니다. 하드링크 자체는 &lt;em&gt;파일로서 존재하는 것이 아니라 디렉토리의 엔트리로 표현되는 것이라 권한이라는 것이 없습니다&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하드링크 생성에는 다음과 같은 제약이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디렉토리간에는 하드링크를 만들 수 없습니다. (C:\A linked to C:\B)&lt;/li&gt;
  &lt;li&gt;다른 볼륨간에 하드링크를 만들 수 없습니다. (C:\A.TXT linked to D:\B.TXT)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 하드링크를 생성하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;하드링크-생성-방법&quot;&gt;하드링크 생성 방법&lt;/h3&gt;

&lt;p&gt;커맨드라인에서 &lt;strong&gt;mklink&lt;/strong&gt; 명령어를 이용하면 하드링크를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음은 기존파일(hello.txt)에 하드링크(bye.txt)를 생성하는 예제입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bat&quot;&gt;C:\temp&amp;gt;echo hello &amp;gt; hello.txt              ; hello.txt 만듭니다.

C:\temp&amp;gt;type hello.txt                      ; hello.txt 내용을 확인합니다.
hello

C:\temp&amp;gt;mklink /H bye.txt hello.txt         ; 하드링크(bye.txt -&amp;gt; hello.txt) 만듭니다.
하드 링크 작성: bye.txt &amp;lt;&amp;lt;===&amp;gt;&amp;gt; hello.txt

C:\temp&amp;gt;type bye.txt                        ; 하드링크 내용을 확인합니다. 
hello

C:\temp&amp;gt;echo bye &amp;gt; bye.txt                  ; 하드링크의 내용을 변경합니다.

C:\temp&amp;gt;type hello.txt                      ; 기존파일(hello.txt)의 내용이 변경된 것을 확인할 수 있습니다.
bye
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mklink 명령어는 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt; API를 사용하여 하드링크를 생성합니다.&lt;/p&gt;

&lt;h3 id=&quot;createhardlink&quot;&gt;CreateHardLink&lt;/h3&gt;

&lt;p&gt;윈도우즈에서 하드링크를 만드는데 사용되는 API가 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt; 사용법은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateHardLinkA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;LPCSTR&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;lpFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;LPCSTR&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;lpExistingFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;LPSECURITY_ATTRIBUTES&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpSecurityAttributes&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;첫번째 인자에 생성될 파일명(하드링크)을 넣어주고, 두번째 인자에 기존(대상) 파일명을 입력해주면 하드링크를 생성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;가 실패를 리턴하는 경우는 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;대상 파일이 존재하지 않는 경우&lt;/li&gt;
  &lt;li&gt;1023개 이상 하드링크를 만들 경우&lt;/li&gt;
  &lt;li&gt;MAX_PATH 길이보다 긴 패스이름이 사용될 경우&lt;/li&gt;
  &lt;li&gt;다른 볼륨에 있는 파일에 하드링크를 거는 경우 (앞서 언급)&lt;/li&gt;
  &lt;li&gt;디렉토리간에 하드링크를 거는 경우 (앞서 언급)&lt;/li&gt;
  &lt;li&gt;또 있을까요?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;하드링크의-재미난-사실&quot;&gt;하드링크의 재미난 사실&lt;/h3&gt;

&lt;p&gt;윈도우즈 보안 연구로 굉장히 유명한 James Forshaw(구글 프로젝트 제로)는 하드링크에 대한 흥미로운 사실&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;을 발표하였습니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;의 구현 내부를 살펴보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CreateHardLinkW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LPCWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LPCWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpExistingFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 생략
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 대상 파일을 Open한다.(FILE_WRITE_ATTRIBUTES 권한을 요구)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NtOpenFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExistingFileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SYNCHRONIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FILE_WRITE_ATTRIBUTES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ObjectAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Open이 실패하면 하드링크 생성 실패를 리턴
&lt;/span&gt; 
    &lt;span class=&quot;c1&quot;&gt;// 생략
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 하드링크 생성요청
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NtSetInformationFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExistingFileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LinkInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileLinkInformation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      
    
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 보면, 하드링크를 생성하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtSetInformationFile&lt;/code&gt;을 사용하고 있음을 알 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt;로 대상 파일을 Open하고나서, &lt;code class=&quot;highlighter-rouge&quot;&gt;NtSetInformationFile&lt;/code&gt;을 호출하는 2단계로 이루어져 있는 것이죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/hardlink/CreateHardLink_1.png&quot; alt=&quot;CreateHardLink&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 주목할 부분은 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt;에 사용된 인자 &lt;code class=&quot;highlighter-rouge&quot;&gt;FILE_WRITE_ATTRIBUTES&lt;/code&gt;입니다. 이것의 의미는 &lt;em&gt;“파일 속성을 변경할 수 있게 파일을 열고 싶어”&lt;/em&gt;라는 의미입니다. 호출자에게 해당 권한이 주어지지 않으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt; 호출은 실패하게 되고 결국 하드링크 생성을 할 수 없습니다. 대상 파일에 속성쓰기 권한이 없으면 하드링크 생성을 못한다? 일견 타당해보이기도 하는데요.&lt;/p&gt;

&lt;p&gt;다음 예는 방금 언급한 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt; 호출이 실패하여 하드링크 생성에 실패하는 것을 보여주고 있습니다. 일반사용자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel32.dll&lt;/code&gt;의 속성을 쓸 수 있는 권한이 없기 때문에 하드링크 생성에 실패한 것이죠.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Test&amp;gt;mklink /H hardlink.txt c:\windows\system32\kernel32.dll
Access is denied.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;James Forshaw는 이 지점에서 읽기 권한만 가진 대상 파일을 Open(&lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt;)해도 하드링크를 생성할 수 있을까?라는 의문을 가지고 테스트를 해봅니다. 그 결과 다음과 같은 사실을 발견하게 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;대상 파일에 대한 Write 권한이 없어도 하드링크를 만들 수 있다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;를 이용하면 권한 문제로 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt; 호출에 실패하여 하드링크를 만들 수 없는 경우(예: &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel32.dll&lt;/code&gt;)가 있었는데, James Forshaw가 발견한 사실을 이용하면 그 경우에도 하드링크를 만들 수 있게 된 것이죠. 이를 증명하기 위해 다음과 같은 POC&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;를 작성하여 공개하였습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 주요부분만 추려냈습니다.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CreateNativeHardlink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LPCWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linkname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LPCWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;targetname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 대상 파일을 Open합니다.(DesiredAccess=MAXIMUM_ALLOWED)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NtOpenFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExistingFileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAXIMUM_ALLOWED&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*이것이 바뀌었습니다*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,,,,);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 하드링크 생성을 요청합니다.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NtSetInformationFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExistingFileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;link_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;link_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileLinkInformation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;는 인자로 &lt;code class=&quot;highlighter-rouge&quot;&gt;FILE_WRITE_ATTRIBUTES&lt;/code&gt;인 반면, James Forshaw가 작성한 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateNativeHardlink&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;MAXIMUM_ALLOWED&lt;/code&gt;를 사용한다는 것이 가장 큰 차이점입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/hardlink/CreateNativeHardLink_1.png&quot; alt=&quot;CreateNativeHardLink&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MAXIMUM_ALLOWED&lt;/code&gt;는 어떻게든 파일을 열어달라는 의미로 보면 됩니다. 즉 &lt;em&gt;어떻게든 대상 파일을 열기만 하면 하드링크 생성이 가능하다&lt;/em&gt;는 점을 코드를 통해 얘기해주고 있는 것이죠.&lt;/p&gt;

&lt;p&gt;James Forshaw가 만든 CreateHardLink.exe을 이용하여 지금까지 설명한 내용을 테스트해 볼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\test&amp;gt;mklink /H hardlink.dll c:\windows\system32\kernel32.dll
액세스가 거부되었습니다.

C:\test&amp;gt;CreateHardlink.exe hardlink.dll c:\windows\system32\kernel32.dll
Done

C:\test&amp;gt;dir
 C 드라이브의 볼륨에는 이름이 없습니다.
 볼륨 일련 번호: 5621-FE76

 C:\test 디렉터리

2019-02-26  오후 12:29    &amp;lt;DIR&amp;gt;          .
2019-02-26  오후 12:29    &amp;lt;DIR&amp;gt;          ..
2019-02-04  오전 12:01           117,760 CreateHardlink.exe
2019-01-09  오전 11:55         1,114,112 hardlink.dll
               2개 파일           1,231,872 바이트
               2개 디렉터리  161,787,883,520 바이트 남음
C:\test&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 테스트를 보면 기본 명령어인 &lt;code class=&quot;highlighter-rouge&quot;&gt;mklink&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;)를 이용하면 하드링크 생성이 불가능했는데, 그러한 경우에도 하드링크를 만들 수 있음을 보여준 것이죠.&lt;/p&gt;

&lt;h3 id=&quot;하드링크-오용hardlink-abusing&quot;&gt;하드링크 오용(Hardlink Abusing)&lt;/h3&gt;

&lt;p&gt;James Forshaw가 발견한 하드링크 문제는 단순 흥미거리로 그치지 않고, 최근까지도 권한상승 익스플로잇에 활용되고 있습니다.&lt;/p&gt;

&lt;p&gt;하드링크가 어떤 문제가 될 수 있을까요?&lt;/p&gt;

&lt;p&gt;쓰기 권한이 없는 대상 파일(예:kernel32.dll)에 하드링크를 걸었다고 생각해봅시다. 하드링크를 통해서 대상 파일을 쓸 수 있을까요? 그렇게 된다면 권한상승 취약점으로 이어질 수 있겠지만 윈도우즈가 그렇게 쉬운 상대는 아닙니다. 윈도우즈는 하드링크가 가리키는 파일에 대한 접근 검사(Access Check)를 통해서 쓰기 시도를 막습니다. 쓰기 권한이 없는 대상 파일에 하드링크를 걸 수는 있으나, 하드링크를 통해서 대상 파일을  쓸 수는 없는 것이죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/hardlink/hardlink_write.png&quot; alt=&quot;hardlink write&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;쓰기 권한이 없는 대상 파일에 하드링크를 걸 수는 있으나, 하드링크를 통해서 대상 파일을  쓸 수는 없는 것이죠.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다른 케이스를 생각해봐야겠네요.&lt;/p&gt;

&lt;p&gt;test 폴더가 있습니다. 일반사용자와 시스템관리자 모두 해당 폴더 밑에 파일을 생성하고 삭제할 수 있는 권한이 주어져 있는 상태입니다. 시스템서비스는 일반사용자도 test\log.txt을 쓸 수 있도록 해당 파일의 퍼미션을 바꾸는 작업을 주기적으로 수행한다고 생각해보죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/hardlink/case_1.png&quot; alt=&quot;case_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 시스템서비스가 test\log.txt 퍼미션을 바꾸려 하기 전에, 일반사용자가 test\log.txt를 삭제하고 하드링크(test\log.txt -&amp;gt; system32\kernel32.dll)를 생성하면 어떻게 될까요? 시스템서비스는 하드링크를 열어 퍼미션을 바꿀 것이고, 결국 하드링크가 가리키던 kernel32.dll 퍼미션이 일반사용자도 파일쓰기 권한을 가지도록 바뀌게 될 것입니다. 파일쓰기 권한이 없던 일반사용자가 시스템의 중요 파일을 쓸 수 있는 상황이 만들어지는 것이죠.&lt;/p&gt;

&lt;p&gt;이와 비슷한 실제 취약점 사례를 바로 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;cve-20188440&quot;&gt;CVE-2018–8440&lt;/h3&gt;

&lt;p&gt;실제 권한 상승 익스플로잇에서는 하드링크를 어떻게 활용하는지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;살펴볼 취약점은 2018년 말에 발표된 &lt;strong&gt;태스크 스케쥴러 서비스&lt;/strong&gt;의 권한상승(EoP) 취약점입니다. 이 취약점은 많은 주목을 받았는데요. 그 이유는 제작자인 &lt;strong&gt;sandboxescaper&lt;/strong&gt;가 제로데이를 그대로 공개해 버렸기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.welivesecurity.com/wp-content/uploads/2018/09/Sandbox-Tweet-Edited.jpg&quot; alt=&quot;sandboxescaper&quot; /&gt; Source: welivesecurity.com&lt;/p&gt;

&lt;p&gt;또한 APT 그룹들이 실제로 오퍼레이션에 활용하였다는 사실&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;이 밝혀지면서 더 이슈가 되었죠.&lt;/p&gt;

&lt;p&gt;태스크 스케쥴러 서비스는 윈도우즈에서 가장 높은 권한인 시스템 권한으로 실행됩니다. 이 서비스는 ALPC 포트라는 일종의 IPC를 통해 외부 프로세스와 통신할 수 있도록 인터페이스를 열어두었습니다.&lt;/p&gt;

&lt;p&gt;열어둔 API 중에서 &lt;strong&gt;SchRpcSetSecurity&lt;/strong&gt;에서 취약점이 발생했는데요. 이 API의 역할은 &lt;em&gt;c:\windows\tasks&lt;/em&gt; 폴더에 있는 파일의 DACL을 조작하는 것입니다. 예를 들어 &lt;em&gt;“일반사용자가 c:\windows\tasks\hello.job 파일을 READ/WRITE하도록 DACL을 변경해주세요”&lt;/em&gt;와 같은 메시지를 서비스에 요청할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/hardlink/sandboxescaper_1.png&quot; alt=&quot;Task Scheduler Service&quot; /&gt;&lt;/p&gt;

&lt;p&gt;tasks 폴더에 위치한 파일의 DACL을 변경할 수 있는 문제와 더불어 “일반 사용자도 tasks 폴더에 파일을 생성(쓰기)할 수 있다”는 사실이 합쳐져 권한상승 익스플로잇이 탄생할 수 있었습니다. 이 과정에서 하드링크가 활용되는데요.&lt;/p&gt;

&lt;p&gt;익스플로잇 과정을 살펴보면서 하드링크의 활용을 이해해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/hardlink/sandboxescaper_2.png&quot; alt=&quot;sandboxescaper exploit&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;tasks 폴더에 &lt;strong&gt;하드링크&lt;/strong&gt;(c:\windows\tasks\UpdateTask.job -&amp;gt; c:\windows\…\PrintConfig.dll)를 하나 생성합니다. &lt;em&gt;일반사용자가 tasks 폴더에 파일을 생성할 수 있고, 대상 파일(PrintConfig.dll)에 하드링크도 걸 수 있으니 1번 작업이 가능해집니다.&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;SchRpcSetSecurity&lt;/em&gt;를 호출하여, “일반사용자가 c:\windows\tasks\UpdateTask.job의 파일쓰기권한을 가지도록” DACL 변경을 요청합니다.&lt;/li&gt;
  &lt;li&gt;태스크 스케쥴러 서비스는 DACL 변경을 수행합니다. 하드링크 대상인 PrintConfig.dll의 DACL을 변경될 것입니다. 일반사용자가 PrintConfig.dll에 대한 쓰기 권한을 갖게 됩니다.&lt;/li&gt;
  &lt;li&gt;익스플로잇이 가진 페이로드로 PrintConfig.dll을 덮어씁니다.&lt;/li&gt;
  &lt;li&gt;스풀러(Spooler) 서비스를 호출하여 PrintConfig.dll을 로드하도록 합니다.&lt;/li&gt;
  &lt;li&gt;스풀러 프로세스 컨텍스트(시스템권한)에서 페이로드가 실행되어 권한상승을 완료합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PrintConfig.dll 외에도 앞서 설명드렸듯이 Open할 수 있는 파일이면 모두 하드링크 대상으로 삼을 수 있습니다.&lt;/p&gt;

&lt;p&gt;이번엔 sandboxescaper가 공개한 익스플로잇 코드&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;에서 하드링크를 생성하는 부분만 살펴보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//Create a hardlink with UpdateTask.job to our target, this is the file the task scheduler will write the DACL of
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateNativeHardlink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;L&quot;c:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;windows&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;UpdateTask.job&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BeginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;James Forshaw가 만든 CreateNativeHardlink를 이용해 하드링크를 만들고 있음을 알 수 있습니다. CreateHardLink(표준 API)를 사용하면 하드링크를 걸 수 없기 때문이죠!&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;James Forshaw가 만든 CreateNativeHardlink를 그대로 재사용하고 있음을 알 수 있습니다. CreateHardLink(표준API)를 사용하면 하드링크를 걸 수 없기 때문이죠!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;대응-방안&quot;&gt;대응 방안&lt;/h3&gt;

&lt;p&gt;James Forshaw가 발견한 하드링크 이슈는 2015년 말에 발표된 내용이지만, 최근까지도 권한상승 익스플로잇에 활용되고 있다는 사실을 실제 사례를 통해 알아보았습니다.&lt;/p&gt;

&lt;p&gt;sandboxescaper의 제로데이 공개 이후 MS가 패치를 릴리즈하기 전까지, 보안 회사와 보안리서처들이 몇 가지 대응방안을 제시했었습니다.&lt;/p&gt;

&lt;p&gt;(a) 스풀러 프로세스 감시&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;스풀러 프로세스(spoolsv.exe)의 자식프로세스 생성 행위를 감시하는 방법입니다. 이 방법의 단점은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스풀러가 아닌 다른 시스템프로세스를 통해서 페이로드를 실행시킬 수 있습니다.&lt;/li&gt;
  &lt;li&gt;스풀러를 통해서 실행되는 페이로드에서 자식프로세스를 생성하지 않는다면 제안된 방법을 쉽게 우회할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(b) tasks 폴더에서 하드링크 생성을 감시하는 방법&lt;sup id=&quot;fnref:6:1&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;하드링크 생성 로그를 확인하는 방법입니다. 하드링크가 tasks 폴더에서 생성된 사실이 있다면 비정상 행위로 보는 것입니다. 이 방법의 단점은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;sandboxescaper의 익스플로잇을 탐지할 수 있으나, 익스플로잇(취약점)이 다른 폴더에 하드링크를 생성할 수 있는 경우라면 탐지하기 어렵습니다. 그렇다고 모든 하드링크 생성 행위를 비정상적으로 판단할 수도 없는 노릇이죠.&lt;/li&gt;
  &lt;li&gt;행위(공격)가 발생했다는 이벤트만 알려줄 뿐, 공격을 차단하지 못합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(c) 익스플로잇 바이트시퀀스(시그니처) 탐지 방법&lt;sup id=&quot;fnref:6:2&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;대부분의 AV에서 택하는 방식일 것이라 생각합니다. 공개된 YARA 룰은 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rule TaskSched
{
 strings:
 $a = “c:\\windows\\tasks” wide ascii nocase
 $b = “.job” wide ascii nocase
 $c = “ncalrpc” wide ascii nocase
 $d = “MZ” wide ascii
 
 condition:
 $a and $b and $c and $d
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;윈도우 실행파일(PE)이고 “.job” “c:\windows\tasks” “ncalrpc” 문자열이 포함되어 있으면 익스플로잇이라고 판단하는 것입니다. 이 방법의 단점은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;문자열을 암호화하는 방법으로 탐지 우회가 가능합니다.&lt;/li&gt;
  &lt;li&gt;오탐(False Positive)의 가능성이 있습니다. 익스플로잇이 아닌 정상실행파일 중에서 저 문자열을 포함하고 있을 가능성도 있는 것이죠. 물론 AV가 사용하는 매칭룰이 저렇게 간단하리라 생각하진 않습니다.&lt;/li&gt;
  &lt;li&gt;패턴매칭 방식은 알려지지 않은 제로데이 취약점에 대해서 탐지하기 어렵다는 단점도 가지고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(d) 태스크 스케쥴러 권한을 낮추는 방법&lt;sup id=&quot;fnref:8&quot;&gt;&lt;a href=&quot;#fn:8&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;(Impersonation)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SchRpcSetSecurity&lt;/code&gt;의 내부 동작 중에서 취약점과 가장 관련이 있었던 부분은 바로 DACL을 변경하는 부분입니다. 여기서 제안한 방법은 태스크 스케쥴러가 DACL을 변경하기 전에 현재 스레드 액세스 토큰 대신 사용자(클라이언트)의 토큰(&lt;em&gt;Impersonation token&lt;/em&gt;)을 사용하여 자원에 접근하도록 하는 것입니다. 이러한 작업을 &lt;em&gt;Impersonation&lt;/em&gt;이라고 하는데요. DACL을 변경하는 작업 전에 태스크 스케쥴러 스레드의 권한을 사용자(클라이언트) 권한으로 잠시 변경하는 것이라 생각하면 됩니다. 이렇게 되면 &lt;em&gt;하드링크대상(예: PrintConfig.dll)의 DACL을 변경할 수 있는 권한이 사용자(클라이언트)에게 없으므로 취약점은 동작하지 않게 됩니다&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/hardlink/impersonation_token.png&quot; alt=&quot;impersonation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 방법이 취약점의 원인(Root Cause)을 정확히 이해하고 내린 적절한 해결책이라 생각합니다. 이 방법을 제안한 0patch라는 제품은 태스크 스케쥴러의 &lt;code class=&quot;highlighter-rouge&quot;&gt;SchRpcSetSecurity&lt;/code&gt; 함수 코드 부분을 바이너리 패치하는 방식으로 &lt;em&gt;Impersonation&lt;/em&gt;을 구현했습니다. 아마 마이크로소프트가 릴리즈한 패치도 &lt;em&gt;Impersonation&lt;/em&gt;을 이용하지 않았을까 추측해봅니다.&lt;/p&gt;

&lt;p&gt;하지만 제안된 방식은 해당 취약점만 패치한 것이라서, 새로 나올 권한상승 취약점 대응과는 무관하다는 단점이 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;x-diffense&quot;&gt;X-DIFFENSE&lt;/h3&gt;

&lt;p&gt;하드링크를 활용하는 권한 상승 익스플로잇에 대한 효과적인 탐지 방안에 대해 소개합니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;하드링크가 필수적으로 동반되는 종류의 권한 상승 익스플로잇의 공통된 특징은 하드링크 대상 파일에 쓰기 권한이 없다&lt;/em&gt;는 점입니다. 익스플로잇이 이미 하드링크 대상 파일에 대해 쓰기 권한이 있다면 하드링크를 걸 필요가 없는 것이죠. 하드링크를 걸어둔다는 것은 취약점을 이용해서 하드링크대상의 쓰기 제한을 풀겠다는 의도니까요. 하드링크가 생성되는 과정에서 그것을 만드는 주체가 하드링크 대상 파일에 쓰기 권한이 없는 경우는 굉장히 의심스러운 행위로 보아야 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;하드링크가 생성되는 과정에서 그것을 만드는 주체가 하드링크 대상 파일에 쓰기 권한이 없는 경우는 굉장히 의심스러운 행위로 보아야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;표준 API인 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;에선 이러한 이상(abnormal) 패턴이 나타날 수 없습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;에선 애초에 파일이 쓰기 가능한 파일에 대해서만 하드링크 생성을 요청하거든요.&lt;/p&gt;

&lt;p&gt;따라서 하드링크를 요청하는 과정에서 하드링크 대상 파일을 “쓰기접근”으로 열지 않은 경우를 탐지할 수 있으면, 하드링크를 활용하는 권한상승 익스플로잇(기존 익스플로잇 및 앞으로 나올 제로데이를 포함하여)을 효과적으로 탐지하고 차단할 수 있습니다.&lt;/p&gt;

&lt;p&gt;X-DIFFENSE(출시예정)는 커널레벨(파일시스템필터)에서 방금 언급한 방법을 적용해 하드링크 를 활용하는 권한상승 시도 행위를 효과적으로 차단할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;MSDN, https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-createhardlinka &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;James Forshaw, Project Zero Blog, https://googleprojectzero.blogspot.com/2015/12/between-rock-and-hard-link.html &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;James Forshaw, SymbolicLink Testing Tools, https://github.com/googleprojectzero/symboliclink-testing-tools &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;PowerPool malware exploits ALPC LPE zero-day vulnerability, https://www.welivesecurity.com/2018/09/05/powerpool-malware-exploits-zero-day-vulnerability/ &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot;&gt;
      &lt;p&gt;Task Scheduler LPE from SandboxEscaper, https://github.com/jackson5-sec/TaskSchedLPE &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot;&gt;
      &lt;p&gt;Task Scheduler ALPC exploit high level analysis – CVE-2018–8440, https://doublepulsar.com/task-scheduler-alpc-exploit-high-level-analysis-ff08cda6ad4f &lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:6:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; &lt;a href=&quot;#fnref:6:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:8&quot;&gt;
      &lt;p&gt;How We Micropatched a Publicly Dropped 0day in Task Scheduler (CVE-2018-8440), https://blog.0patch.com/2018/08/how-we-micropatched-publicly-dropped.html &lt;a href=&quot;#fnref:8&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 22 Feb 2019 00:00:00 +0900</pubDate>
      </item>
    
  </channel>
</rss>
