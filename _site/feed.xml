<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
	<channel>
		<title>Diffense</title>
		<description>{&quot;meta&quot;=&gt;nil, &quot;subtitle&quot;=&gt;nil}</description>
		<link>http://localhost:4000</link>
		<atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Better than spoolsv</title>
				
					<dc:creator>{&quot;name&quot;=&gt;&quot;Yongil Lee of Diffense&quot;}</dc:creator>
				
				
					<description>&lt;p&gt;안녕하세요. 디펜스입니다.&lt;/p&gt;

&lt;p&gt;이전 글(&lt;a href=&quot;http://blog.diffense.co.kr/2019/02/22/hard-link/&quot;&gt;Windows HardLink Attack &amp;amp; Defense&lt;/a&gt;)에서 우리는 &lt;em&gt;sandboxescaper&lt;/em&gt;의 익스플로잇이 &lt;em&gt;스풀러 서비스(Spoolsv)&lt;/em&gt;를 통해서 최종적으로 페이로드를 실행한다는 점을 살펴보았습니다. 복습하는 차원에서 그 과정을 단순화하면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/kkjjll/raw/master/spooler_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;태스크스케쥴러 서비스 취약점 호출(DACL 변경할 수 있는 취약점)&lt;/li&gt;
  &lt;li&gt;취약점을 이용해 스풀러가 사용하는 PrintConfig.dll에 대한 쓰기 권한 획득&lt;/li&gt;
  &lt;li&gt;PrintConfig.dll을 페이로드로 덮어씀&lt;/li&gt;
  &lt;li&gt;스풀러 서비스 호출&lt;/li&gt;
  &lt;li&gt;스플러 서비스(시스템권한)를 통해 페이로드 실행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여기서 취약점 트리거(~2번)는 성공했는데 3~5번 과정에서 실패하는 경우가 있을까요? 즉 취약점은 잘 동작하였으나, 스풀러 서비스로 페이로드를 올리는 과정(3~5번)이 실패하는 경우 말이죠. 만약 3~5번 과정이 실패하면 페이로드를 시스템 권한에서 실행시킬 수 있는 다른 방법을 모색해봐야 할 것입니다.&lt;/p&gt;

&lt;p&gt;이번 글의 주제는 위와 같은 상황에서 스풀러 서비스 대신 &lt;em&gt;페이로드를 시스템 권한으로 실행할 수 있는 다른 방법&lt;/em&gt;을 알아보자는 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;windows-eop-0-day&quot;&gt;Windows EoP 0-day&lt;/h3&gt;

&lt;p&gt;저희가 연구 목적으로 개발한 &lt;em&gt;윈도우즈 권한상승(EoP) 0-day&lt;/em&gt;는 다음과 같이 동작합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/kkjjll/raw/master/our_eop.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;‘음? 앞선 그림이랑 똑같은거 아닌가요?’ 네 맞습니다. 동작 상세 내용을 몰라도 설명하는 것에 문제가 없기 때문이에요. 해당 취약점을 이용하면 임의 파일의 DACL을 변경할 수 있습니다. 그리고 중요한 점은 &lt;em&gt;시스템 권한의 페이로드를 실행하기 위해 sandboxescaper가 사용한 스풀러 서비스 방식(3~5번 과정)을 그대로 차용&lt;/em&gt;했다는 점입니다.&lt;/p&gt;

&lt;h3 id=&quot;printconfigdll-사용중&quot;&gt;PrintConfig.dll 사용중?&lt;/h3&gt;

&lt;p&gt;취약점 연구 조직들은 정기적인 시큐리티 업데이트(예:Patch Tuesday&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;)에 맞춰 자신들이 가지고 있는 취약점을 테스트합니다. ‘취약점이 패치되었는지? 패치되었다면 어떤 식으로?’ 등을 확인하는 목적이지요.&lt;/p&gt;

&lt;p&gt;저희 역시 그러한 테스트를 진행하던 중에 해당 PoC가 미동작하는 상황을 발견하게 되었습니다. 그럼 미동작 원인을 분석해 보아야 하겠죠? 같이 한번 살펴보도록 해요.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;취약점은 살아있는가?
    &lt;ul&gt;
      &lt;li&gt;위 그림에서 1~2번 단계가 제대로 실행되는지 확인을 해보면 취약점 패치 여부를 알 수 있을 것입니다.&lt;/li&gt;
      &lt;li&gt;PoC를 실행하고서, PrintConfig.dll의 DACL이 변경되었는지를 살펴보았습니다. 
&lt;img src=&quot;https://github.com/yong1212/kkjjll/raw/master/PrintConfig_after.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;빨간색 박스를 보면 Users가 PrintConfig.dll에 대한 모든 권한(Full)을 가지고 있는 것을 확인할 수 있습니다. DACL이 변경된 것을 확인하였고, 따라서 &lt;em&gt;취약점은 패치되지 않은 채 여전히 존재&lt;/em&gt;한다고 볼 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PrintConfig.dll은 페이로드로 교체되었나?
    &lt;ul&gt;
      &lt;li&gt;확인을 해보니 PrintConfig.dll이 페이로드로 교체되지 않았습니다. 쓰기 권한은 있는데 쓸 수가 없다? 무슨 문제일까요?&lt;/li&gt;
      &lt;li&gt;문제의 원인은 다음 그림을 보면 알 수 있습니다.
&lt;img src=&quot;https://github.com/yong1212/kkjjll/raw/master/PrintConfig.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;바로 spoolsv.exe에서 PrintConfig.dll을 사용하고 있었던 것이죠.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;spoolsv.exe가 DriverStore\PrintConfig.dll을 사용하는 경우가 있었습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PrintConfig.dll&lt;/code&gt;이 스풀러에 의해 이미 사용되고 있어, &lt;code class=&quot;highlighter-rouge&quot;&gt;Users&lt;/code&gt;에게 모든 권한(쓰기포함)이 주어졌음에도 해당 파일을 덮어쓸 수 없는 상황이었던 것이죠.&lt;/p&gt;

&lt;h3 id=&quot;another-option&quot;&gt;Another option?&lt;/h3&gt;

&lt;p&gt;스풀러 서비스를 통해 페이로드를 실행시키는 방법이 실패할 수 있는 케이스를 알아보았습니다.&lt;/p&gt;

&lt;p&gt;그럼 이제 대안이 필요한 상황이군요. 즉 취약점을 이용해 임의의 파일을 쓰기 가능 상태로 만들 수 있을 경우(2번  단계까지 가능한 경우), 스풀러 서비스 방법 대신 페이로드를 실행시킬 수 있는 다른 방법은 어떤 것이 있을까요?&lt;/p&gt;

&lt;h3 id=&quot;diagnostics-hub-standard-collector&quot;&gt;Diagnostics Hub Standard Collector&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Diagnostics Hub Standard Collector 서비스(줄여서 D-Hub)&lt;/em&gt;는 시스템 권한으로 돌아가는 윈도우즈 서비스입니다. 우리는 스풀러 대신 이 서비스를 활용해 볼 것입니다.&lt;/p&gt;

&lt;p&gt;이 서비스의 존재를 알게 된 계기는 Lokihardt(구글 프로젝트 제로)가 Pwn2Own 2016을 통해 해당 서비스의 취약점 &lt;code class=&quot;highlighter-rouge&quot;&gt;CVE-2016-3231&lt;/code&gt;을 공개하고 나서인데요. 취약점을 우선 간단히 설명하고, 이 서비스를 어떻게 활용할 수 있는 지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;D-Hub는 &lt;code class=&quot;highlighter-rouge&quot;&gt;AddAgent&lt;/code&gt;라는 API를 사용자(클라이언트)에게 제공합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/kkjjll/raw/master/DHub_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AddAgent&lt;/code&gt;의 인자로 DLL 파일명을 주면, 그 파일명은 &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadLibrary&lt;/code&gt;(DLL 로드하는 함수)의 인자로 사용됩니다. 사용자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;AddAgent&lt;/code&gt;를 호출하여 D-Hub가 로드할 Dll을 지정할 수 있는 것입니다.&lt;/p&gt;

&lt;p&gt;Lokihardt는 이 부분에서 아래 그림처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;Directory Traversal&lt;/code&gt; 취약점을 발견하여 Edge 샌드박스 탈출에 성공했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/kkjjll/raw/master/DHub_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 취약점은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Directory Traversal&lt;/code&gt;이 발생하지 않도록 패치가 되었습니다.&lt;/p&gt;

&lt;p&gt;우리가 지금 관심있는 것은 취약점이 아니라, 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;AddAgent&lt;/code&gt;라는 기능입니다. 이 기능을 이용하면 &lt;em&gt;System32 폴더에 있는 DLL을 D-Hub 서비스(시스템권한)로 로드할 수 있기 때문&lt;/em&gt;이죠. (정확히 말하면 DLL Search Order&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;로 정해진 폴더 순으로 DLL을 검색합니다. 설명의 편의를 위해 System32 폴더를 예로 들겠습니다.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AddAgent를 이용하면 System32 폴더에 있는 DLL을 D-Hub 서비스(시스템권한)로 로드할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;참고)
&lt;em&gt;D-Hub 기능을 활용할 수 있을 지 조사를 하던 중, James Forshaw가 이미 관련 내용&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;을 자세히 공개한 것을 확인할 수 있었습니다. 좋은 발표 많이 해주는 James Forshaw에게 다시 한번 감사!&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;d-hub-방식의-장점&quot;&gt;D-Hub 방식의 장점?&lt;/h3&gt;

&lt;p&gt;D-Hub를 이용하는 방식은 스풀러에 비해 어떤 장점이 있을까요?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;D-Hub를 이용하면 System32에 있는 많은 DLL 중에서 사용중이지 않은 DLL을 선택해서 로드할 수 있다는 장점이 있습니다. PrintConfig.dll이 사용 중인 경우에는 스풀러를 이용하지 못하는 반면, D-Hub를 이용하면 수많은 DLL 중 하나를 선택해서 로드시킬 수 있다는 장점이 있는 것이죠.
&lt;img src=&quot;https://github.com/yong1212/kkjjll/raw/master/DHub_Better.png&quot; alt=&quot;&quot; /&gt;
    &lt;blockquote&gt;
      &lt;p&gt;D-Hub를 이용하면 사용 중이지 않은 DLL을 선택해서 로드시킬 수 있어요.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;스풀러를 이용하려면 PrintConfig.dll의 경로를 확인하는 과정이 필요하다는 단점이 있습니다. PrintConfig.dll 경로가 고정적이지 않기 때문이예요. 참고로 sandboxescaper는 PrintConfig.dll 경로를 구하기 위해 다음과 같은 코드&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;를 작성했습니다.
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;WIN32_FIND_DATA&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FindFileData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hFind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hFind&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FindFirstFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;L&quot;C:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Windows&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;System32&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;DriverStore&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;FileRepository&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;prnms003.inf_amd64*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FindFileData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BeginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_PATH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;c:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;windows&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;system32&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;DriverStore&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;FileRepository&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrinterDriverFolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_PATH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EndPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Amd64&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;PrintConfig.dll&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;wmemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PrinterDriverFolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FindFileData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wcslen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FindFileData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FindClose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hFind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;wcscat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BeginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrinterDriverFolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;wcscat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BeginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EndPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;D-Hub 방식은 이런 과정이 필요 없습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;demo&quot;&gt;Demo&lt;/h3&gt;

&lt;p&gt;스풀러 방식에서 D-Hub으로 바꾼 후 EoP 0-day 테스트를 진행해 보았습니다. 
(페이로드로 덮어쓸 파일은 &lt;code class=&quot;highlighter-rouge&quot;&gt;System32\CIRCoInst.dll&lt;/code&gt;을 선택했습니다.)&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/cBIXxn85oLM&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;동영상 데모의 단계별 설명입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;최신 업데이트임을 확인합니다.&lt;/li&gt;
  &lt;li&gt;whoami를 이용해 현재 사용자(관리자 아님)를 확인합니다.&lt;/li&gt;
  &lt;li&gt;c:\windows\system32\whoami.txt 에 파일이 존재하지 않음을 확인합니다.&lt;/li&gt;
  &lt;li&gt;icacls 명령을 이용해 c:\windows\system32\CIRCoInst.dll 파일의 DACL을 확인합니다.
    &lt;ul&gt;
      &lt;li&gt;Users 그룹을 확인해 주세요.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PoC를 실행합니다.&lt;/li&gt;
  &lt;li&gt;실행이 끝나면 CIRCoInst.dll의 DACL을 다시 한번 확인합니다.
    &lt;ul&gt;
      &lt;li&gt;Users 그룹이 모든 권한(Full)을 가지도록 변경되었는지 확인합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Process Explorer를 실행하여, D-Hub 프로세스(DiagnosticsHub.StandardCollector.Service.exe)가 실행되었는지 확인합니다.&lt;/li&gt;
  &lt;li&gt;D-Hub 프로세스를 통해 페이로드가 실행되었는지 확인합니다.
    &lt;ul&gt;
      &lt;li&gt;페이로드는 whoami &amp;gt; c:\windows\system32\whoami.txt 를 실행하도록 되어 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;c:\windows\system32\whoami.txt 내용을 열어 System인지 확인합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;마치며&quot;&gt;마치며&lt;/h3&gt;

&lt;p&gt;취약점 연구를 하는 목적은 분명합니다. 해킹 공격을 효과적으로 탐지하고 차단할 수 있는 기술 개발에 이러한 취약점 연구가 기반이 된다고 믿습니다. 디펜스는 연구 산출물을 고객에게 우선적으로 제공하여 최신 해킹 위협에 대응할 수 있도록 합니다.&lt;/p&gt;

&lt;p&gt;감사합니다. 다음 번 블로그에서 뵙겠습니다!&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Patch Tuesday, https://en.wikipedia.org/wiki/Patch_Tuesday &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;Dynamic-Link Library Search Order, https://docs.microsoft.com/en-us/windows/desktop/dlls/dynamic-link-library-search-order &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;Windows Exploitation Tricks: Exploiting Arbitrary File Writes for Local Elevation of Privilege, https://googleprojectzero.blogspot.com/2018/04/windows-exploitation-tricks-exploiting.html &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;https://github.com/jackson5-sec/TaskSchedLPE/blob/master/Original/ALPC-TaskSched-LPE/ALPC-TaskSched-LPE.cpp#L83 &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
				
				<pubDate>Sat, 02 Mar 2019 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2019/03/02/Eop-DHub/</link>
				<guid isPermaLink="true">http://localhost:4000/2019/03/02/Eop-DHub/</guid>
			</item>
		
			<item>
				<title>Windows HardLink Attack &amp; Defense</title>
				
					<dc:creator>{&quot;name&quot;=&gt;&quot;Yongil Lee of Diffense&quot;}</dc:creator>
				
				
					<description>&lt;p&gt;안녕하세요! 디펜스입니다.&lt;/p&gt;

&lt;p&gt;이번 글에서는 하드링크란 무엇이며, 익스플로잇에서 활용되는 하드링크와 일반적인 하드링크와의 차이점이 무엇인지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;또한, 실제 권한상승 익스플로잇(CVE-2018–8440) 사례를 통해 하드링크가 어떤 식으로 활용되고 있는지 알아봅니다.&lt;/p&gt;

&lt;p&gt;마지막으로 하드링크를 활용한 권한상승 익스플로잇을 효과적으로 탐지할 수 있는 방안에 대해 소개하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;하드링크&quot;&gt;하드링크?&lt;/h3&gt;
&lt;p&gt;(하드링크에 대해 알고 계신 분은 건너뛰세요!)&lt;/p&gt;

&lt;p&gt;윈도우즈 하드링크는 동일한 파일을 참조하는 여러 개의 파일명을 만들 수 있는 기능입니다.&lt;/p&gt;

&lt;p&gt;그림 하나면 쉽게 이해할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Hard_Link_Illustration.svg/314px-Hard_Link_Illustration.svg.png&quot; alt=&quot;hardlink&quot; /&gt; 출처: Wikipedia&lt;/p&gt;

&lt;p&gt;위 그림을 보면 실제 파일이 NTFS 파일시스템 볼륨(C드라이브)내 어딘가에 존재하고 있고, 우리는 이 파일을 A.TXT라는 파일명으로 링크하여 참조하고 있음을 볼 수 있습니다. 하드링크를 이용하면 해당 파일을 참조하는 또 다른 파일명(B.TXT)을 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;만약 하드링크를 통해 파일 내용을 수정하거나 삭제 혹은 권한을 변경하면 어떻게 될까요?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하드링크 수정
    &lt;ul&gt;
      &lt;li&gt;A.TXT, B.TXT는 &lt;em&gt;모두 같은 파일에 대한 링크&lt;/em&gt;라서 둘 중 어떤 링크를 수정하더라도 동일한 결과가 나옵니다.&lt;/li&gt;
      &lt;li&gt;A.TXT를 수정한 다음 B.TXT 내용을 보면 서로 내용이 동일한 것을 알 수 있습니다. 물론 역도 마찬가지입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하드링크 삭제
    &lt;ul&gt;
      &lt;li&gt;파일은 &lt;em&gt;링크 참조 카운트&lt;/em&gt;를 내부적으로 유지하고 있습니다. 예제의 경우 링크 참조 카운트는 2가 될 것입니다.&lt;/li&gt;
      &lt;li&gt;하나의 링크를 삭제하면 그것이 가리키는 파일의 링크 참조카운트가 1씩 감소합니다. 참조카운트가 0이 되면 최종적으로 파일이 삭제됩니다.&lt;/li&gt;
      &lt;li&gt;하나의 링크(A.TXT)를 삭제하더라도 다른 링크(B.TXT)가 살아있다면 해당 파일을 계속 참조할 수 있는 것이죠.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일의 권한을 변경하려는 경우
    &lt;ul&gt;
      &lt;li&gt;기존 링크(A.TXT)나 새로 생성된 하드링크(B.TXT) 둘 중 어떤 링크를 통해 권한을 바꾸어도 둘의 결과는 동일합니다. 링크가 가리키는 파일의 권한이 변경되는 것이죠.&lt;/li&gt;
      &lt;li&gt;탐색기를 열어 A.TXT 파일의 권한을 수정한 후 B.TXT 권한을 확인해보세요. 동일함을 확인할 수 있을 겁니다. 역도 마찬가지입니다.&lt;/li&gt;
      &lt;li&gt;링크 자체의 권한은 어떻게 바꾸는지 궁금한 분들이 있을 것입니다. 하드링크 자체는 &lt;em&gt;파일로서 존재하는 것이 아니라 디렉토리의 엔트리로 표현되는 것이라 권한이라는 것이 없습니다&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하드링크 생성에는 다음과 같은 제약이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디렉토리간에는 하드링크를 만들 수 없습니다. (C:\A linked to C:\B)&lt;/li&gt;
  &lt;li&gt;다른 볼륨간에 하드링크를 만들 수 없습니다. (C:\A.TXT linked to D:\B.TXT)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 하드링크를 생성하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;하드링크-생성-방법&quot;&gt;하드링크 생성 방법&lt;/h3&gt;

&lt;p&gt;커맨드라인에서 &lt;strong&gt;mklink&lt;/strong&gt; 명령어를 이용하면 하드링크를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음은 기존파일(hello.txt)에 하드링크(bye.txt)를 생성하는 예제입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bat&quot;&gt;C:\temp&amp;gt;echo hello &amp;gt; hello.txt              ; hello.txt 만듭니다.

C:\temp&amp;gt;type hello.txt                      ; hello.txt 내용을 확인합니다.
hello

C:\temp&amp;gt;mklink /H bye.txt hello.txt         ; 하드링크(bye.txt -&amp;gt; hello.txt) 만듭니다.
하드 링크 작성: bye.txt &amp;lt;&amp;lt;===&amp;gt;&amp;gt; hello.txt

C:\temp&amp;gt;type bye.txt                        ; 하드링크 내용을 확인합니다. 
hello

C:\temp&amp;gt;echo bye &amp;gt; bye.txt                  ; 하드링크의 내용을 변경합니다.

C:\temp&amp;gt;type hello.txt                      ; 기존파일(hello.txt)의 내용이 변경된 것을 확인할 수 있습니다.
bye
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mklink 명령어는 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt; API를 사용하여 하드링크를 생성합니다.&lt;/p&gt;

&lt;h3 id=&quot;createhardlink&quot;&gt;CreateHardLink&lt;/h3&gt;

&lt;p&gt;윈도우즈에서 하드링크를 만드는데 사용되는 API가 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt; 사용법은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateHardLinkA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;LPCSTR&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;lpFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;LPCSTR&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;lpExistingFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;LPSECURITY_ATTRIBUTES&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpSecurityAttributes&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;첫번째 인자에 생성될 파일명(하드링크)을 넣어주고, 두번째 인자에 기존(대상) 파일명을 입력해주면 하드링크를 생성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;가 실패를 리턴하는 경우는 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;대상 파일이 존재하지 않는 경우&lt;/li&gt;
  &lt;li&gt;1023개 이상 하드링크를 만들 경우&lt;/li&gt;
  &lt;li&gt;MAX_PATH 길이보다 긴 패스이름이 사용될 경우&lt;/li&gt;
  &lt;li&gt;다른 볼륨에 있는 파일에 하드링크를 거는 경우 (앞서 언급)&lt;/li&gt;
  &lt;li&gt;디렉토리간에 하드링크를 거는 경우 (앞서 언급)&lt;/li&gt;
  &lt;li&gt;또 있을까요?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;하드링크의-재미난-사실&quot;&gt;하드링크의 재미난 사실&lt;/h3&gt;

&lt;p&gt;윈도우즈 보안 연구로 굉장히 유명한 James Forshaw(구글 프로젝트 제로)는 하드링크에 대한 흥미로운 사실&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;을 발표하였습니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;의 구현 내부를 살펴보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CreateHardLinkW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LPCWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LPCWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpExistingFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 생략
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 대상 파일을 Open한다.(FILE_WRITE_ATTRIBUTES 권한을 요구)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NtOpenFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExistingFileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SYNCHRONIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FILE_WRITE_ATTRIBUTES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ObjectAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Open이 실패하면 하드링크 생성 실패를 리턴
&lt;/span&gt; 
    &lt;span class=&quot;c1&quot;&gt;// 생략
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 하드링크 생성요청
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NtSetInformationFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExistingFileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LinkInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileLinkInformation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      
    
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 보면, 하드링크를 생성하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtSetInformationFile&lt;/code&gt;을 사용하고 있음을 알 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt;로 대상 파일을 Open하고나서, &lt;code class=&quot;highlighter-rouge&quot;&gt;NtSetInformationFile&lt;/code&gt;을 호출하는 2단계로 이루어져 있는 것이죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/hardlink/CreateHardLink_1.png&quot; alt=&quot;CreateHardLink&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 주목할 부분은 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt;에 사용된 인자 &lt;code class=&quot;highlighter-rouge&quot;&gt;FILE_WRITE_ATTRIBUTES&lt;/code&gt;입니다. 이것의 의미는 &lt;em&gt;“파일 속성을 변경할 수 있게 파일을 열고 싶어”&lt;/em&gt;라는 의미입니다. 호출자에게 해당 권한이 주어지지 않으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt; 호출은 실패하게 되고 결국 하드링크 생성을 할 수 없습니다. 대상 파일에 속성쓰기 권한이 없으면 하드링크 생성을 못한다? 일견 타당해보이기도 하는데요.&lt;/p&gt;

&lt;p&gt;다음 예는 방금 언급한 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt; 호출이 실패하여 하드링크 생성에 실패하는 것을 보여주고 있습니다. 일반사용자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel32.dll&lt;/code&gt;의 속성을 쓸 수 있는 권한이 없기 때문에 하드링크 생성에 실패한 것이죠.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Test&amp;gt;mklink /H hardlink.txt c:\windows\system32\kernel32.dll
Access is denied.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;James Forshaw는 이 지점에서 읽기 권한만 가진 대상 파일을 Open(&lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt;)해도 하드링크를 생성할 수 있을까?라는 의문을 가지고 테스트를 해봅니다. 그 결과 다음과 같은 사실을 발견하게 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;대상 파일에 대한 Write 권한이 없어도 하드링크를 만들 수 있다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;를 이용하면 권한 문제로 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt; 호출에 실패하여 하드링크를 만들 수 없는 경우(예: &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel32.dll&lt;/code&gt;)가 있었는데, James Forshaw가 발견한 사실을 이용하면 그 경우에도 하드링크를 만들 수 있게 된 것이죠. 이를 증명하기 위해 다음과 같은 POC&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;를 작성하여 공개하였습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 주요부분만 추려냈습니다.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CreateNativeHardlink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LPCWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linkname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LPCWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;targetname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 대상 파일을 Open합니다.(DesiredAccess=MAXIMUM_ALLOWED)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NtOpenFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExistingFileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAXIMUM_ALLOWED&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*이것이 바뀌었습니다*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,,,,);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 하드링크 생성을 요청합니다.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NtSetInformationFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExistingFileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;link_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;link_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileLinkInformation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;는 인자로 &lt;code class=&quot;highlighter-rouge&quot;&gt;FILE_WRITE_ATTRIBUTES&lt;/code&gt;인 반면, James Forshaw가 작성한 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateNativeHardlink&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;MAXIMUM_ALLOWED&lt;/code&gt;를 사용한다는 것이 가장 큰 차이점입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/hardlink/CreateNativeHardLink_1.png&quot; alt=&quot;CreateNativeHardLink&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MAXIMUM_ALLOWED&lt;/code&gt;는 어떻게든 파일을 열어달라는 의미로 보면 됩니다. 즉 &lt;em&gt;어떻게든 대상 파일을 열기만 하면 하드링크 생성이 가능하다&lt;/em&gt;는 점을 코드를 통해 얘기해주고 있는 것이죠.&lt;/p&gt;

&lt;p&gt;James Forshaw가 만든 CreateHardLink.exe을 이용하여 지금까지 설명한 내용을 테스트해 볼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\test&amp;gt;mklink /H hardlink.dll c:\windows\system32\kernel32.dll
액세스가 거부되었습니다.

C:\test&amp;gt;CreateHardlink.exe hardlink.dll c:\windows\system32\kernel32.dll
Done

C:\test&amp;gt;dir
 C 드라이브의 볼륨에는 이름이 없습니다.
 볼륨 일련 번호: 5621-FE76

 C:\test 디렉터리

2019-02-26  오후 12:29    &amp;lt;DIR&amp;gt;          .
2019-02-26  오후 12:29    &amp;lt;DIR&amp;gt;          ..
2019-02-04  오전 12:01           117,760 CreateHardlink.exe
2019-01-09  오전 11:55         1,114,112 hardlink.dll
               2개 파일           1,231,872 바이트
               2개 디렉터리  161,787,883,520 바이트 남음
C:\test&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 테스트를 보면 기본 명령어인 &lt;code class=&quot;highlighter-rouge&quot;&gt;mklink&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;)를 이용하면 하드링크 생성이 불가능했는데, 그러한 경우에도 하드링크를 만들 수 있음을 보여준 것이죠.&lt;/p&gt;

&lt;h3 id=&quot;하드링크-오용hardlink-abusing&quot;&gt;하드링크 오용(Hardlink Abusing)&lt;/h3&gt;

&lt;p&gt;James Forshaw가 발견한 하드링크 문제는 단순 흥미거리로 그치지 않고, 최근까지도 권한상승 익스플로잇에 활용되고 있습니다.&lt;/p&gt;

&lt;p&gt;하드링크가 어떤 문제가 될 수 있을까요?&lt;/p&gt;

&lt;p&gt;쓰기 권한이 없는 대상 파일(예:kernel32.dll)에 하드링크를 걸었다고 생각해봅시다. 하드링크를 통해서 대상 파일을 쓸 수 있을까요? 그렇게 된다면 권한상승 취약점으로 이어질 수 있겠지만 윈도우즈가 그렇게 쉬운 상대는 아닙니다. 윈도우즈는 하드링크가 가리키는 파일에 대한 접근 검사(Access Check)를 통해서 쓰기 시도를 막습니다. 쓰기 권한이 없는 대상 파일에 하드링크를 걸 수는 있으나, 하드링크를 통해서 대상 파일을  쓸 수는 없는 것이죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/hardlink/hardlink_write.png&quot; alt=&quot;hardlink write&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;쓰기 권한이 없는 대상 파일에 하드링크를 걸 수는 있으나, 하드링크를 통해서 대상 파일을  쓸 수는 없는 것이죠.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다른 케이스를 생각해봐야겠네요.&lt;/p&gt;

&lt;p&gt;test 폴더가 있습니다. 일반사용자와 시스템관리자 모두 해당 폴더 밑에 파일을 생성하고 삭제할 수 있는 권한이 주어져 있는 상태입니다. 시스템서비스는 일반사용자도 test\log.txt을 쓸 수 있도록 해당 파일의 퍼미션을 바꾸는 작업을 주기적으로 수행한다고 생각해보죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/hardlink/case_1.png&quot; alt=&quot;case_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 시스템서비스가 test\log.txt 퍼미션을 바꾸려 하기 전에, 일반사용자가 test\log.txt를 삭제하고 하드링크(test\log.txt -&amp;gt; system32\kernel32.dll)를 생성하면 어떻게 될까요? 시스템서비스는 하드링크를 열어 퍼미션을 바꿀 것이고, 결국 하드링크가 가리키던 kernel32.dll 퍼미션이 일반사용자도 파일쓰기 권한을 가지도록 바뀌게 될 것입니다. 파일쓰기 권한이 없던 일반사용자가 시스템의 중요 파일을 쓸 수 있는 상황이 만들어지는 것이죠.&lt;/p&gt;

&lt;p&gt;이와 비슷한 실제 취약점 사례를 바로 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;cve-20188440&quot;&gt;CVE-2018–8440&lt;/h3&gt;

&lt;p&gt;실제 권한 상승 익스플로잇에서는 하드링크를 어떻게 활용하는지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;살펴볼 취약점은 2018년 말에 발표된 &lt;strong&gt;태스크 스케쥴러 서비스&lt;/strong&gt;의 권한상승(EoP) 취약점입니다. 이 취약점은 많은 주목을 받았는데요. 그 이유는 제작자인 &lt;strong&gt;sandboxescaper&lt;/strong&gt;가 제로데이를 그대로 공개해 버렸기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.welivesecurity.com/wp-content/uploads/2018/09/Sandbox-Tweet-Edited.jpg&quot; alt=&quot;sandboxescaper&quot; /&gt; Source: welivesecurity.com&lt;/p&gt;

&lt;p&gt;또한 APT 그룹들이 실제로 오퍼레이션에 활용하였다는 사실&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;이 밝혀지면서 더 이슈가 되었죠.&lt;/p&gt;

&lt;p&gt;태스크 스케쥴러 서비스는 윈도우즈에서 가장 높은 권한인 시스템 권한으로 실행됩니다. 이 서비스는 ALPC 포트라는 일종의 IPC를 통해 외부 프로세스와 통신할 수 있도록 인터페이스를 열어두었습니다.&lt;/p&gt;

&lt;p&gt;열어둔 API 중에서 &lt;strong&gt;SchRpcSetSecurity&lt;/strong&gt;에서 취약점이 발생했는데요. 이 API의 역할은 &lt;em&gt;c:\windows\tasks&lt;/em&gt; 폴더에 있는 파일의 DACL을 조작하는 것입니다. 예를 들어 &lt;em&gt;“일반사용자가 c:\windows\tasks\hello.job 파일을 READ/WRITE하도록 DACL을 변경해주세요”&lt;/em&gt;와 같은 메시지를 서비스에 요청할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/hardlink/sandboxescaper_1.png&quot; alt=&quot;Task Scheduler Service&quot; /&gt;&lt;/p&gt;

&lt;p&gt;tasks 폴더에 위치한 파일의 DACL을 변경할 수 있는 문제와 더불어 “일반 사용자도 tasks 폴더에 파일을 생성(쓰기)할 수 있다”는 사실이 합쳐져 권한상승 익스플로잇이 탄생할 수 있었습니다. 이 과정에서 하드링크가 활용되는데요.&lt;/p&gt;

&lt;p&gt;익스플로잇 과정을 살펴보면서 하드링크의 활용을 이해해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/hardlink/sandboxescaper_2.png&quot; alt=&quot;sandboxescaper exploit&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;tasks 폴더에 &lt;strong&gt;하드링크&lt;/strong&gt;(c:\windows\tasks\UpdateTask.job -&amp;gt; c:\windows\…\PrintConfig.dll)를 하나 생성합니다. &lt;em&gt;일반사용자가 tasks 폴더에 파일을 생성할 수 있고, 대상 파일(PrintConfig.dll)에 하드링크도 걸 수 있으니 1번 작업이 가능해집니다.&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;SchRpcSetSecurity&lt;/em&gt;를 호출하여, “일반사용자가 c:\windows\tasks\UpdateTask.job의 파일쓰기권한을 가지도록” DACL 변경을 요청합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;태스크 스케쥴러 서비스는 DACL 변경을 수행합니다. 하드링크 대상인 PrintConfig.dll의 DACL을 변경될 것입니다. 일반사용자가 PrintConfig.dll에 대한 쓰기 권한을 갖게 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;익스플로잇이 가진 페이로드로 PrintConfig.dll을 덮어씁니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스풀러(Spooler) 서비스를 호출하여 PrintConfig.dll을 로드하도록 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스풀러 프로세스 컨텍스트(시스템권한)에서 페이로드가 실행되어 권한상승을 완료합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PrintConfig.dll 외에도 앞서 설명드렸듯이 Open할 수 있는 파일이면 모두 하드링크 대상으로 삼을 수 있습니다.&lt;/p&gt;

&lt;p&gt;이번엔 sandboxescaper가 공개한 익스플로잇 코드&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;에서 하드링크를 생성하는 부분만 살펴보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//Create a hardlink with UpdateTask.job to our target, this is the file the task scheduler will write the DACL of
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateNativeHardlink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;L&quot;c:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;windows&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;UpdateTask.job&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BeginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;James Forshaw가 만든 CreateNativeHardlink를 이용해 하드링크를 만들고 있음을 알 수 있습니다. CreateHardLink(표준 API)를 사용하면 하드링크를 걸 수 없기 때문이죠!&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;James Forshaw가 만든 CreateNativeHardlink를 그대로 재사용하고 있음을 알 수 있습니다. CreateHardLink(표준API)를 사용하면 하드링크를 걸 수 없기 때문이죠!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;대응-방안&quot;&gt;대응 방안&lt;/h3&gt;

&lt;p&gt;James Forshaw가 발견한 하드링크 이슈는 2015년 말에 발표된 내용이지만, 최근까지도 권한상승 익스플로잇에 활용되고 있다는 사실을 실제 사례를 통해 알아보았습니다.&lt;/p&gt;

&lt;p&gt;sandboxescaper의 제로데이 공개 이후 MS가 패치를 릴리즈하기 전까지, 보안 회사와 보안리서처들이 몇 가지 대응방안을 제시했었습니다.&lt;/p&gt;

&lt;p&gt;(a) 스풀러 프로세스 감시&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;스풀러 프로세스(spoolsv.exe)의 자식프로세스 생성 행위를 감시하는 방법입니다. 이 방법의 단점은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스풀러가 아닌 다른 시스템프로세스를 통해서 페이로드를 실행시킬 수 있습니다.&lt;/li&gt;
  &lt;li&gt;스풀러를 통해서 실행되는 페이로드에서 자식프로세스를 생성하지 않는다면 제안된 방법을 쉽게 우회할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(b) tasks 폴더에서 하드링크 생성을 감시하는 방법&lt;sup id=&quot;fnref:6:1&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;하드링크 생성 로그를 확인하는 방법입니다. 하드링크가 tasks 폴더에서 생성된 사실이 있다면 비정상 행위로 보는 것입니다. 이 방법의 단점은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;sandboxescaper의 익스플로잇을 탐지할 수 있으나, 익스플로잇(취약점)이 다른 폴더에 하드링크를 생성할 수 있는 경우라면 탐지하기 어렵습니다. 그렇다고 모든 하드링크 생성 행위를 비정상적으로 판단할 수도 없는 노릇이죠.&lt;/li&gt;
  &lt;li&gt;행위(공격)가 발생했다는 이벤트만 알려줄 뿐, 공격을 차단하지 못합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(c) 익스플로잇 바이트시퀀스(시그니처) 탐지 방법&lt;sup id=&quot;fnref:6:2&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;대부분의 AV에서 택하는 방식일 것이라 생각합니다. 공개된 YARA 룰은 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rule TaskSched
{
 strings:
 $a = “c:\\windows\\tasks” wide ascii nocase
 $b = “.job” wide ascii nocase
 $c = “ncalrpc” wide ascii nocase
 $d = “MZ” wide ascii
 
 condition:
 $a and $b and $c and $d
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;윈도우 실행파일(PE)이고 “.job” “c:\windows\tasks” “ncalrpc” 문자열이 포함되어 있으면 익스플로잇이라고 판단하는 것입니다. 이 방법의 단점은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;문자열을 암호화하는 방법으로 탐지 우회가 가능합니다.&lt;/li&gt;
  &lt;li&gt;오탐(False Positive)의 가능성이 있습니다. 익스플로잇이 아닌 정상실행파일 중에서 저 문자열을 포함하고 있을 가능성도 있는 것이죠. 물론 AV가 사용하는 매칭룰이 저렇게 간단하리라 생각하진 않습니다.&lt;/li&gt;
  &lt;li&gt;패턴매칭 방식은 알려지지 않은 제로데이 취약점에 대해서 탐지하기 어렵다는 단점도 가지고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(d) 태스크 스케쥴러 권한을 낮추는 방법&lt;sup id=&quot;fnref:8&quot;&gt;&lt;a href=&quot;#fn:8&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;(Impersonation)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SchRpcSetSecurity&lt;/code&gt;의 내부 동작 중에서 취약점과 가장 관련이 있었던 부분은 바로 DACL을 변경하는 부분입니다. 여기서 제안한 방법은 태스크 스케쥴러가 DACL을 변경하기 전에 현재 스레드 액세스 토큰 대신 사용자(클라이언트)의 토큰(&lt;em&gt;Impersonation token&lt;/em&gt;)을 사용하여 자원에 접근하도록 하는 것입니다. 이러한 작업을 &lt;em&gt;Impersonation&lt;/em&gt;이라고 하는데요. DACL을 변경하는 작업 전에 태스크 스케쥴러 스레드의 권한을 사용자(클라이언트) 권한으로 잠시 변경하는 것이라 생각하면 됩니다. 이렇게 되면 &lt;em&gt;하드링크대상(예: PrintConfig.dll)의 DACL을 변경할 수 있는 권한이 사용자(클라이언트)에게 없으므로 취약점은 동작하지 않게 됩니다&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/hardlink/impersonation_token.png&quot; alt=&quot;impersonation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 방법이 취약점의 원인(Root Cause)을 정확히 이해하고 내린 적절한 해결책이라 생각합니다. 이 방법을 제안한 0patch라는 제품은 태스크 스케쥴러의 &lt;code class=&quot;highlighter-rouge&quot;&gt;SchRpcSetSecurity&lt;/code&gt; 함수 코드 부분을 바이너리 패치하는 방식으로 &lt;em&gt;Impersonation&lt;/em&gt;을 구현했습니다. 아마 마이크로소프트가 릴리즈한 패치도 &lt;em&gt;Impersonation&lt;/em&gt;을 이용하지 않았을까 추측해봅니다.&lt;/p&gt;

&lt;p&gt;하지만 제안된 방식은 해당 취약점만 패치한 것이라서, 새로 나올 권한상승 취약점 대응과는 무관하다는 단점이 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;x-diffense&quot;&gt;X-DIFFENSE&lt;/h3&gt;

&lt;p&gt;하드링크를 활용하는 권한 상승 익스플로잇에 대한 효과적인 탐지 방안에 대해 소개합니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;하드링크가 필수적으로 동반되는 종류의 권한 상승 익스플로잇의 공통된 특징은 하드링크 대상 파일에 쓰기 권한이 없다&lt;/em&gt;는 점입니다. 익스플로잇이 이미 하드링크 대상 파일에 대해 쓰기 권한이 있다면 하드링크를 걸 필요가 없는 것이죠. 하드링크를 걸어둔다는 것은 취약점을 이용해서 하드링크대상의 쓰기 제한을 풀겠다는 의도니까요. 하드링크가 생성되는 과정에서 그것을 만드는 주체가 하드링크 대상 파일에 쓰기 권한이 없는 경우는 굉장히 의심스러운 행위로 보아야 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;하드링크가 생성되는 과정에서 그것을 만드는 주체가 하드링크 대상 파일에 쓰기 권한이 없는 경우는 굉장히 의심스러운 행위로 보아야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;표준 API인 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;에선 이러한 이상(abnormal) 패턴이 나타날 수 없습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;에선 애초에 파일이 쓰기 가능한 파일에 대해서만 하드링크 생성을 요청하거든요.&lt;/p&gt;

&lt;p&gt;따라서 하드링크를 요청하는 과정에서 하드링크 대상 파일을 “쓰기접근”으로 열지 않은 경우를 탐지할 수 있으면, 하드링크를 활용하는 권한상승 익스플로잇(기존 익스플로잇 및 앞으로 나올 제로데이를 포함하여)을 효과적으로 탐지하고 차단할 수 있습니다.&lt;/p&gt;

&lt;p&gt;X-DIFFENSE(출시예정)는 커널레벨(파일시스템필터)에서 방금 언급한 방법을 적용해 하드링크 를 활용하는 권한상승 시도 행위를 효과적으로 차단할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;MSDN, https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-createhardlinka &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;James Forshaw, Project Zero Blog, https://googleprojectzero.blogspot.com/2015/12/between-rock-and-hard-link.html &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;James Forshaw, SymbolicLink Testing Tools, https://github.com/googleprojectzero/symboliclink-testing-tools &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;PowerPool malware exploits ALPC LPE zero-day vulnerability, https://www.welivesecurity.com/2018/09/05/powerpool-malware-exploits-zero-day-vulnerability/ &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot;&gt;
      &lt;p&gt;Task Scheduler LPE from SandboxEscaper, https://github.com/jackson5-sec/TaskSchedLPE &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot;&gt;
      &lt;p&gt;Task Scheduler ALPC exploit high level analysis – CVE-2018–8440, https://doublepulsar.com/task-scheduler-alpc-exploit-high-level-analysis-ff08cda6ad4f &lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:6:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; &lt;a href=&quot;#fnref:6:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:8&quot;&gt;
      &lt;p&gt;How We Micropatched a Publicly Dropped 0day in Task Scheduler (CVE-2018-8440), https://blog.0patch.com/2018/08/how-we-micropatched-publicly-dropped.html &lt;a href=&quot;#fnref:8&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
				
				<pubDate>Fri, 22 Feb 2019 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2019/02/22/hard-link/</link>
				<guid isPermaLink="true">http://localhost:4000/2019/02/22/hard-link/</guid>
			</item>
		
	</channel>
</rss>
