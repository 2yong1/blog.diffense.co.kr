---
title: 하드링크 오용 탐지 방법

summary: 하드링크란 무엇이며, 취약점을 악용하는데 하드링크는 어떻게 활용되는지 살펴본다.

author: 
    name: Yongil Lee of Diffense

---

James Forshaw가 발견한 윈도우즈에서의 하드 링크 오용 방법의 원리를 알아보고, 이를 악용한 실제 윈도우즈 권한상승(EoP) 취약점 사례를 살펴보고자 합니다. 

또한, 디펜스에서 출시 예정인 X-DIFFENSE에서 하드 링크 오용을 통한 권한상승 취약점을 어떻게 효과적으로 탐지하고 차단하는지에 대해 소개합니다.

### 하드 링크?

하드 링크는 하나의 파일에 여러 개의 이름을 만들 수 있는 기능입니다.

Hello.txt에 대해 하드링크(Bye.txt)를 생성한다면, 동일한 파일을 표현하는 서로 다른 2개의 이름(Hello.txt와 Bye.txt)을 가지게 되는 것이라고 생각하면 이해하기 편합니다.

Hello.txt가 "Hello"라는 내용을 가지고 있으면, Bye.txt 를 읽어보면 같은 내용을 가지고 있습니다. 같은 파일을 가리키고 있으니 그런 것입니다.

파일 삭제는 어떨까요? Hello.txt를 삭제하면 링크(Hello.txt)만 삭제됩니다. 원래 있던 파일을 지우더라도 Bye.txt을 통해 여전히 파일에 접근할 수 있습니다. 파일을 참조하는 하드링크가 모두 삭제되면 최종적으로 파일이 삭제됩니다. 

하드링크의 퍼미션을 바꾼다면 하드링크가 나타내는 파일의 퍼미션이 바뀌게 됩니다. 사실 하드링크는 디렉토리 엔트리라서 퍼미션이라는 것이 없습니다. 하드링크가 가리키는 파일에 퍼미션이 있습니다. Bye.txt에서 탐색기를 열어 권한을 수정한 뒤 Hello.txt의 권한을 확인해보면 동일하게 바뀌어 있음을 확인할 수 있습니다. 2개의 하드링크가 가리키는 동일 파일에 대해 퍼미션을 수정하고 확인한 것입니다.

그러면 모든 파일에 대해 하드링크를 만들 수 있을까요? 하드 링크 생성에는 다음과 같은 제약이 있습니다.

* 디렉토리간에는 하드링크를 만들 수 없습니다. (C:\dira linked to C:\dirb)
* 다른 볼륨간에 하드링크를 만들 수 없습니다. (C:\dira\ethel.txt linked to D:\dirb\lucy.txt)

### 하드링크 생성 방법

mklink 명령어를 이용하면 하드링크를 만들 수 있습니다.

다음 예는 기존파일(hello.txt)에 하드링크(bye.txt)를 생성하는 명령입니다.

```
mklink /H bye.txt hello.txt
```

mklink 명령어는 `CreateHardLink` API를 사용하여 하드링크 생성을 윈도우즈OS에 요청합니다. 

CreateHardLink Syntax[^1]는 다음과 같습니다.

```c
BOOL CreateHardLinkA(
  LPCSTR                lpFileName,
  LPCSTR                lpExistingFileName,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes
);
```

첫번째 인자에 생성될 파일명(하드링크)을 넣어주고, 두번째 인자에 기존파일명을 입력해주면 하드링크를 생성할 수 있습니다. 

MSDN은 CreateHardLink가 실패하는 케이스를 설명하고 있습니다.  
* 하나 
* 둘

### 하드링크의 재미난 사실 

James Forshaw는 윈도우즈 하드링크와 관련한 흥미로운 사실[^1]을 발견하게 됩니다.

먼저 하드링크 생성에 사용되는 `CreateHardLink` API 의 구현 내부를 살펴보죠.

```c
BOOL CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName) {
    // 생략

    // 타겟파일을 Open한다.(FILE_WRITE_ATTRIBUTES 권한을 요구)
    status = NtOpenFile(&ExistingFileHandle, SYNCHRONIZE | FILE_WRITE_ATTRIBUTES, &ObjectAttributes, ...);
    if (status < 0) return FALSE;   // Open이 실패하면 하드링크 생성 실패를 리턴
 
    // 생략

    // 하드링크 생성요청
    status = NtSetInformationFile(ExistingFileHandle, LinkInfo, target.Length + 16, FileLinkInformation);
    if ( status < 0 ) return FALSE;      
    
    return TRUE;
}
```

코드에서 보면 알 수 있듯이, 내부적으로 `NtOpenFile`과 `NtSetInformationFile`을 호출하여 하드링크를 생성하게 됩니다.

여기서 눈여겨 볼 점은 타겟파일을 Open하는 데 `FILE_WRITE_ATTRIBUTES`을 인자로 사용한 것인데요. 만약 사용자가 타겟파일에 대해 `FILE_WRITE_ATTRIBUTES`으로 열기 권한이 없으면, 하드링크를 만들 수 없음을 의미합니다.

다음은 사용자가 System32\kernel32.dll에 대해 방금 언급한 권한이 없기 때문에 하드링크를 생성할 수 없음을 예로 보여줍니다.

```
C:\Test>mklink /H hardlink.txt c:\windows\system32\kernel32.dll
Access is denied.
```

James Forshaw는 이 지점에서 FILE_WRITE_ATTRIBUTES 없이 타겟파일을 Open하면 어떻게 될까? 라는 의문을 가지고 실험을 해보기 시작합니다. 실험 결과, 다음과 같은 사실을 발견하게 됩니다.

>대상 파일에 대한 Write 권한이 없어도 하드링크를 만들 수 있다

mklink(CreateHardLink)를 이용하면 하드링크를 만들 수 없는 경우(예:kernel32.dll)가 있었는데, James Forshaw가 발견한 사실을 이용하면 그 경우에도 하드링크를 만들 수 있게 된 것이죠. 이를 증명하기 위해 다음과 같은 코드를 작성하여 공개[^2]하였습니다.

```c
bool CreateNativeHardlink(LPCWSTR linkname, LPCWSTR targetname)
{
    // 중략
    NtOpenFile(&ExistingFileHandle, MAXIMUM_ALLOWED/*이것이 바뀌었습니다*/,,,,);

    // 중략
    NtSetInformationFile(ExistingFileHandle, &io_status, link_info, link_info.size(), FileLinkInformation);
}
```

여기서 CreateHardLink와의 중요한 차이점은 CreateHardLink는 대상파일을 오픈할 때 요청한 권한이 FILE_WRITE_ATTRIBUTES 였지만, James Forshaw가 작성한 CreateNativeHardlink에서는 MAXIMUM_ALLOWED로 바뀌었다는 점입니다. 

MAXIMUM_ALLOWED는 어떻게든 파일을 열어달라는 의미로 보면 됩니다. 즉 *어떻게든 대상파일을 열기만 하면 하드링크 생성이 가능*함을 코드를 통해 말해주고 있습니다.

James Forshaw가 작성한 CreateHardLink.exe 툴을 이용하여 지금까지 설명한 내용을 테스트해 볼 수 있습니다.

```
CreateHardLink.exe hardlink.exe c:\windows\system32\kernel32.dll
dir hardlink.exe
```

mklink를 이용하면 생성할 수 없었던 하드링크를, James Forshaw가 만든 툴을 이용하면 하드링크를 만들 수 있음을 확인할 수 있습니다.

### 하드링크 오용(Hardlink Abusing)

James Forshaw가 발견한 하드링크 문제는 단순 흥미거리로 그치지 않고, 최근까지도 권한상승 익스플로잇에 활용되고 있습니다.

하드링크가 어떤 문제가 될 수 있을까요?

WRITE 권한이 없는 대상파일(예: c:\windows\notepad.exe)에 하드링크를 걸었다고 생각해봅시다. 하드링크를 통해서 대상파일(notepad.exe)을 WRITE할 수 있을까요? 만약 그렇게 된다면 바로 권한상승 취약점으로 이어질 수 있지만, 앞서 언급했듯이 하드링크는 디렉토리엔트리로서 그 자체로 퍼미션을 가지고 있지 않고 하드링크가 가리키는 파일이 퍼미션을 가지고 있기 때문에 하드링크를 통해서 WRITE 시도를 하게 되면, 그것이 가리키는 파일에 대한 접근검사가 이루어져서 WRITE 시도가 실패하게 되죠. 

정리하면 Write권한이 없는 대상파일에 대해 하드링크를 생성할 수는 있으나 하드링크를 통한 Write는 허용이 되지 않는다고 얘기할 수 있겠습니다.

다른 케이스를 생각해 보겠습니다. C:\Test 라는 디렉토리가 있다고 합시다. 이 디렉토리에는 일반사용자와 시스템관리자 모두 파일 생성/쓰기/삭제 권한이 주어져 있는 상태입니다. 또한, 시스템서비스가 C:\Test\A.TXT 파일을 열어 "Hello"라는 로그를 주기적으로 남긴다고 가정해보겠습니다. 

만약 시스템서비스가 C:\Test\A.TXT를 열기 전에, 일반사용자(해커)가 A.TXT를 삭제함과 동시에 C:\Windows\System32\kernel32.dll를 가리키는 하드링크(C:\Test\A.TXT)를 생성하면 어떻게 될까요? 시스템서비스는 하드링크를 열어 "Hello" 로그를 WRITE하려 할 것이고, 시스템서비스는 kernel32.dll에 대한 Write권한이 있으므로 kernel32.dll은 결국 "Hello"로그로 더렵혀지겠죠. 파일쓰기권한이 없던 사용자가 하드링크를 이용하면(취약점과 함께) 시스템의 중요 파일을 Write할 수 있게 되는 것이죠.

하드링크를 이용한 취약점 공격 방법은 아니고 오래전부터 유닉스 계열의 운영체제에서는 활용되어 온 방식입니다. 하지만 윈도우즈 운영체제에서 취약점 공격에 하드링크를 활용하기 시작한 건 James Forshaw의 발견 이후라고 보는 것이 맞습니다. 왜냐하면 하드링크를 이용한다는 것은 결국 해커가 쓰기권한이 없는 파일에 대해 하드링크를 걸어줘야 하는게 필수적인데, James Forshaw 발견 전에는 윈도우즈 운영체제에서 그런 사실을 모두 몰랐기 때문이죠.

하지만 그게 다입니다. 대상파일에 쓰기가 허용되지 않는다면, 하드링크를 통해서 쓰는 것 역시 허용되지 않습니다. 그럼 취약점이 없는 것 아닙니까? 라고 생각할 수 있을 것입니다.

만약 높은 권한(Admin이나 System권한)으로 돌아가는 서비스프로세스가 있다고 생각해봅시다.

이 서비스프로세스는 (어떤이유에서인지는 몰라도) 특정 디렉토리 위치에 있는 파일의 퍼미션을 바꾸는 작업을 합니다. 해당 파일에 대해 일반 사용자(User 그룹)도 쓰기 권한을 가지도록 퍼미션을 바꾼다고 생각해보자는 거죠. 

여기서 만약 일반 사용자가 디렉토리의 파일 생성과 삭제 권한을 가진다면, 권한 상승 취약점으로 발전시킬 수 있습니다. 하드링크를 통해서 말이죠. 

시스템프로세스가 파일의 퍼미션을 변경하기 직전에, 일반사용자가 해당 파일을 삭제하는 동시에 동일한 이름의 하드링크(타겟 예: System32\kernel32.dll)를 만들게 되면 어떻게 될까요?

시스템프로세스는 하드링크에 대해 퍼미션 변경작업을 수행하게 될 것이고, 결국 일반 사용자가 쓰기 접근이 불가능했던 파일(에:kernel32.dll)에 대해 쓰기 권한을 획득할 수 있게 됩니다.

### CVE-2018–8440

실제 권한 상승 익스플로잇에서는 하드링크를 어떻게 활용하는지 살펴보겠습니다.

살펴볼 취약점은 2018년 말에 발표된 **태스크 스케쥴러 서비스**의 권한상승(EoP) 취약점입니다. 이 취약점은 많은 주목을 받았는데요. 그 이유는 제작자인 **sandboxescaper**가 제로데이를 그대로 공개해 버렸기 때문입니다. 또한 APT 그룹에서 자신들의 오퍼레이션에 즉시 활용할 수 있을 정도의 제로데이였기 때문에(실제로 APT그룹에서 활용하였다는 사실이 밝혀졌습니다), 많은 시스템들이 위험에 노출되어 버린 상황이 되어 더 이슈가 되었죠.

이슈가 된 만큼 많은 분석 보고서들을 인터넷에서 찾아볼 수 있습니다. 이 글에서는 취약점 자체에 대해선 대략적으로 살펴볼 것이고, 하드링크가 어떻게 활용되었는지에 대해 초점을 두고 얘기하려 합니다. 

일단 취약점이 있었던 태스크 스케쥴러 서비스는 윈도우즈에서 가장 높은 권한인 시스템(SYSTEM)권한으로 실행됩니다. 이 서비스는 ALPC 포트라는 일종의 IPC를 통해 외부 프로세스와 통신할 수 있도록 인터페이스를 열어두었습니다. 

열어둔 API 중에서 **SchRpcSetSecurity**에서 취약점이 발생했습니다. 이 API의 역할은 *c:\windows\tasks* 폴더에 있는 파일의 DACL을 제어할 수 있는 것인데요. 예를 들어 *"일반사용자가 c:\windows\tasks\hello.txt 파일을 READ/WRITE하도록 DACL을 변경해주세요"*와 같은 메시지를 서비스에 요청할 수 있습니다.

tasks 폴더에 위치한 파일의 DACL을 변경할 수 있는 문제와 더불어 "일반 사용자도 tasks 폴더에 파일을 생성(쓰기)할 수 있다"는 사실이 합쳐져 권한상승 익스플로잇이 탄생할 수 있었습니다. 이 과정에서 하드링크가 활용되는데요.

익스플로잇 과정을 살펴보면서 하드링크의 활용을 이해해보겠습니다.

1. tasks 폴더에 **하드링크**(c:\windows\tasks\UpdateTask.job -> c:\windows\system32\kernel32.dll)을 하나 생성합니다.
2. SchRpcSetSecurity를 호출하여, "일반사용자가 c:\windows\tasks\UpdateTask.job 파일을 쓸 수 있도록" DACL 변경을 요청합니다.
3. 태스크스케쥴러는 해당 DACL 변경 요청을 처리해줍니다. 태스크스케쥴러는 DACL 변경대상이 하드링크인지 아닌지 여부와 상관없이 해당 파일의 DACL을 변경해줍니다. 결국 하드링크 대상인 kernel32.dll의 DACL을 변경해버리는 결과가 발생합니다. 즉 일반사용자가 kernel32.dll에 대한 쓰기 권한을 갖게 되는 결과가 되어 버리는 거죠.

위 예에서는 kernel32.dll을 예로 들었지만, 앞서 설명드렸듯이 Open할 수 있는 파일이면 모두 하드링크 대상으로 삼을 수 있습니다. 

sandboxescaper는 하드링크 타겟으로 `C:\Windows\System32\DriverStore\FileRepository\prnms003.inf_amd64` 밑에 있는 PrintConfig.dll을 선택했습니다. 취약점을 이용해 PrintConfig.dll를 쓰기 가능하도록 만든 다음, 해당 dll을 자신의 페이로드로 교체한 후 스풀러(Spooler) 서비스를 호출하여 PrintConfig.dll(페이로드)을 물고 올라가도록 하여 최종적으로 자신의 페이로드가 스풀러 프로세스 컨텍스트(시스템권한)에서 실행되도록 하는 것이죠. 

### 대처 방안

앞서 언급한 하드링크를 통한 권한상승 취약점 유형은 언제든지 발견될 수 있습니다. 

취약점 대처 방안으로 익스플로잇이 발견될 때마다 그것에 맞춰 대응하는 방법(패턴매칭)이 대부분의 AV업체 등에서 

이러한 방법은 제로데이 익스플로잇에 대해서는 탐지율이 낮다는 단점이 있습니다.

저희 디펜스에서 출시 예정인 X-DIFFENSE에서는 하드링크를 오용하기 위해선 일반적인 CreateHardLink를 이용하는 것이 아니라, JF가 제안한 방식을 이용해야 한다는 점에 착안하여, JF 방식을 이용하면 이를 차단하는 방식을 채택했습니다. (CreateHardLink 표준 API를 사용하지 않고 다른 방법으로 하드링크를 생성한다는 것은 분명 abnormal한 behavior라고 볼 수 있습니다.)

이런 방식을 적용하면, 하드링크를 활용하여 권한상승을 시도하는 (알려지지 않은 제로데이까지 포함한)해킹공격을 효과적으로 방어할 수 있습니다.

하드링크를 쓸 경우가 많지 않은데 하물며 CreateHardLink 표준을 사용하지 않는다면 굉장히 흔치 않은 행위라고 판단하는 겁니다. 거의 JF 방식은 일반(정상적인) 프로세스가 사용하는 경우가 거의 없습니다.

X-DIFFENSE는 커널레벨(파일시스템필터)에서 하드링크 생성 과정을 감시하고 차단합니다. 

* 하드링크의 오용을 방지하는 방안




[^1]: MSDN, https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-createhardlinka

[^1]: https://googleprojectzero.blogspot.com/2015/12/between-rock-and-hard-link.html

[^2]: https://github.com/googleprojectzero/symboliclink-testing-tools/blob/master/CommonUtils/Hardlink.cpp#L20













