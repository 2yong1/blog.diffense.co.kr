---
title: 하드링크 오용 탐지 방법

summary: 하드링크란 무엇이며, 취약점을 악용하는데 하드링크는 어떻게 활용되는지 살펴본다.

author: 
    name: Yongil Lee of Diffense

---

James Forshaw가 발견한 윈도우즈에서의 하드 링크 오용 방법의 원리를 알아보고, 이를 악용한 실제 윈도우즈 권한상승(EoP) 취약점 사례를 살펴보고자 합니다. 

또한, 디펜스에서 출시 예정인 X-DIFFENSE에서 하드 링크 오용을 통한 권한상승 취약점을 어떻게 효과적으로 탐지하고 차단하는지에 대해 소개합니다.

### 하드 링크?

하드 링크는 하나의 파일에 여러 개의 이름을 만들 수 있는 기능입니다.

Hello.txt에 대해 하드링크(Bye.txt)를 생성한다면, 동일한 파일을 표현하는 서로 다른 2개의 이름(Hello.txt와 Bye.txt)을 가지게 되는 것이구나라고 생각하는 것이 이해하기 편합니다.

Hello.txt가 "Hello"라는 내용을 가지고 있으면, Bye.txt 를 읽어보면 같은 내용을 가지고 있습니다. 같은 파일을 나타내는 서로 다른 이름에 불과하니 당연한 것이죠.

하드링크의 퍼미션을 바꾼다면 하드링크가 나타내는 파일의 퍼미션이 바뀌게 됩니다. 사실 하드링크는 디렉토리 엔트리라서 퍼미션이라는 것이 없습니다. 하드링크가 가리키는 파일에 퍼미션이 있습니다. Bye.txt에서 탐색기를 열어 권한을 수정한 뒤 Hello.txt의 권한을 확인해보면 동일하게 바뀌어 있음을 확인할 수 있습니다. 2개의 하드링크가 가리키는 동일 파일에 대해 퍼미션을 수정하고 확인한 것에 불과합니다.

파일 삭제는 어떨까요? Hello.txt를 삭제하면 Hello.txt는 이름(디렉토리엔트리)에 불과하므로 이름(Hello.txt)만 삭제됩니다. Bye.txt을 통해 여전히 파일에 접근할 수 있습니다. 파일을 참조하는 하드링크가 모두 삭제되면 최종적으로 파일이 삭제됩니다. 

그러면 모든 파일에 대해 하드링크를 만들 수 있을까요? 

하드 링크 생성에는 다음과 같은 제약이 있습니다.

* 디렉토리간에는 하드링크를 만들 수 없습니다. (C:\dira linked to C:\dirb)
* 다른 볼륨간에 하드링크를 만들 수 없습니다. (C:\dira\ethel.txt linked to D:\dirb\lucy.txt)

### 하드링크 생성 방법

mklink 명령어를 이용하면 하드링크를 만들 수 있습니다.

다음 예는 기존파일(hello.txt)에 하드링크(bye.txt)를 생성하는 명령입니다.

```
mklink /H bye.txt hello.txt
```

mklink 명령어는 `CreateHardLink` API를 사용하여 하드링크 생성을 윈도우즈OS에 요청합니다. 

CreateHardLink API의 Syntax는 다음과 같습니다.

```c
BOOL CreateHardLinkA(
  LPCSTR                lpFileName,
  LPCSTR                lpExistingFileName,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes
);
```

간단합니다. 첫번째 인자에 생성될 파일명(하드링크)을 넣어주고, 두번째 인자에 기존파일명을 입력해주면 하드링크를 생성할 수 있습니다. 

### 하드링크 오용(Hardlink abusing)

James Forshaw는 하드링크와 관련한 흥미로운 사실[^1]을 발견하게 됩니다.

먼저 하드링크 생성에 사용되는 `CreateHardLink` API 의 구현 내부를 살펴보죠.

```c
BOOL CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName) {
    // 생략

    // 기존파일을 Open한다.(FILE_WRITE_ATTRIBUTES 권한을 요구)
    status = NtOpenFile(&ExistingFileHandle, SYNCHRONIZE | FILE_WRITE_ATTRIBUTES, &ObjectAttributes, ...);
    if (status < 0) return FALSE;   // Open이 실패하면 하드링크 생성 실패를 리턴
 
    // 생략

    // 하드링크 생성요청
    status = NtSetInformationFile(ExistingFileHandle, LinkInfo, target.Length + 16, FileLinkInformation);
    if ( status < 0 ) return FALSE;      
    
    return TRUE;
}
```

코드에서 보면 알 수 있듯이, 내부적으로 `NtOpenFile`과 `NtSetInformationFile`을 호출하여 하드링크를 생성하게 됩니다.

여기서 눈여겨 볼 점은, 기존파일을 Open하는 데 `FILE_WRITE_ATTRIBUTES`이 인자로 사용되었다는 것인데요. 만약 사용자가 기존파일에 대해 `FILE_WRITE_ATTRIBUTES` 권한을 가지고 있지 않다면 하드링크를 만들 수 없음을 의미합니다.

다음은 사용자가 System32\kernel32.dll에 대해 방금 언급한 권한이 없기 때문에 하드링크를 생성할 수 없음을 예로 보여줍니다.

```
C:\Test>mklink /H hardlink.txt c:\windows\system32\kernel32.dll
Access is denied.
```

James Forshaw는 이 지점에서 FILE_WRITE_ATTRIBUTES 없이 파일을 Open하면 어떻게 될까? 라는 의문을 가지고 실험을 해보기 시작합니다. 실험 결과, 다음과 같은 사실을 발견하게 됩니다.

>대상 파일에 대한 Write 권한이 없어도 하드링크를 만들 수 있다

mklink(CreateHardLink)를 이용하면 하드링크를 만들 수 없는 경우(예:kernel32.dll)가 있었는데, James Forshaw가 발견한 사실을 이용하면 그 경우에도 하드링크를 만들 수 있게 된 것이죠. 이를 증명하기 위해 다음과 같은 코드를 작성하여 공개[^2]하였습니다.

```c
bool CreateNativeHardlink(LPCWSTR linkname, LPCWSTR targetname)
{
    // 중략
    NtOpenFile(&ExistingFileHandle, MAXIMUM_ALLOWED/*이것이 바뀌었습니다*/,,,,);

    // 중략
    NtSetInformationFile(ExistingFileHandle, &io_status, link_info, link_info.size(), FileLinkInformation);
}
```

여기서 CreateHardLink와의 중요한 차이점은 CreateHardLink는 대상파일을 오픈할 때 요청한 권한이 FILE_WRITE_ATTRIBUTES 였지만, James Forshaw가 작성한 CreateNativeHardlink에서는 MAXIMUM_ALLOWED로 바뀌었다는 점입니다. 

MAXIMUM_ALLOWED의 의미는 현재 사용자가 대상파일에 대해 허용되는 모든 권한을 가지고 파일을 오픈하겠다는 것인데, 어떻게든 파일을 열어달라는 의미로 보면 됩니다. 즉 *어떻게든 대상파일을 열기만 하면 하드링크 생성이 가능*함을 코드를 통해 말해주고 있습니다.

James Forshaw가 작성한 CreateHardLink.exe 툴을 이용하여 지금까지 설명한 내용을 테스트해 볼 수 있습니다.

```
CreateHardLink.exe hardlink.exe c:\windows\system32\kernel32.dll
dir hardlink.exe
```

mklink를 이용하면 생성할 수 없었던 하드링크를, James Forshaw가 만든 툴을 이용하면 하드링크를 만들 수 있음을 확인할 수 있습니다.

### 하드링크 오용(Hardlink Abusing)

일반 유저 권한에서 거의 모든 파일(같은 볼륨 내)에 대해서 하드링크를 생성할 수 있음을 설명했습니다.

이것이 어떤 문제가 될 수 있을까요?

WRITE 권한이 없는 대상파일(예: c:\windows\notepad.exe)에 하드링크를 걸었다고 생각해봅시다. 하드링크를 통해서 대상파일(notepad.exe)을 WRITE할 수 있을까요? 만약 그렇게 된다면 바로 권한상승 취약점으로 이어질 수 있지만, 앞서 언급했듯이 하드링크는 디렉토리엔트리로서 그 자체로 퍼미션을 가지고 있지 않고 하드링크가 가리키는 파일이 퍼미션을 가지고 있기 때문에 하드링크를 통해서 WRITE 시도를 하게 되면, 그것이 가리키는 파일에 대한 접근검사가 이루어져서 WRITE 시도가 실패하게 되죠. 

정리하면 Write권한이 없는 대상파일에 대해 하드링크를 생성할 수는 있으나 하드링크를 통한 Write는 허용이 되지 않는다고 얘기할 수 있겠습니다.

다른 케이스를 생각해 보겠습니다. C:\Test 라는 디렉토리가 있다고 합시다. 이 디렉토리에는 일반사용자와 시스템관리자 모두 파일 생성/쓰기/삭제 권한이 주어져 있는 상태입니다. 또한, 시스템서비스가 C:\Test\A.TXT 파일을 열어 "Hello"라는 로그를 주기적으로 남긴다고 가정해보겠습니다. 

만약 시스템서비스가 C:\Test\A.TXT를 열기 전에, 일반사용자(해커)가 A.TXT를 삭제함과 동시에 C:\Windows\System32\kernel32.dll를 가리키는 하드링크(C:\Test\A.TXT)를 생성하면 어떻게 될까요? 시스템서비스는 하드링크를 열어 "Hello" 로그를 WRITE하려 할 것이고, 시스템서비스는 kernel32.dll에 대한 Write권한이 있으므로 kernel32.dll은 결국 "Hello"로그로 더렵혀지겠죠. 파일쓰기권한이 없던 사용자가 하드링크를 이용하면(취약점과 함께) 시스템의 중요 파일을 Write할 수 있게 되는 것이죠.

하드링크를 이용한 취약점 공격 방법은 아니고 오래전부터 유닉스 계열의 운영체제에서는 활용되어 온 방식입니다. 하지만 윈도우즈 운영체제에서 취약점 공격에 하드링크를 활용하기 시작한 건 James Forshaw의 발견 이후라고 보는 것이 맞습니다. 왜냐하면 하드링크를 이용한다는 것은 결국 해커가 쓰기권한이 없는 파일에 대해 하드링크를 걸어줘야 하는게 필수적인데, James Forshaw 발견 전에는 윈도우즈 운영체제에서 그런 사실을 모두 몰랐기 때문이죠.

하지만 그게 다입니다. 대상파일에 쓰기가 허용되지 않는다면, 하드링크를 통해서 쓰는 것 역시 허용되지 않습니다. 그럼 취약점이 없는 것 아닙니까? 라고 생각할 수 있을 것입니다.

만약 높은 권한(Admin이나 System권한)으로 돌아가는 서비스프로세스가 있다고 생각해봅시다.

이 서비스프로세스는 (어떤이유에서인지는 몰라도) 특정 디렉토리 위치에 있는 파일의 퍼미션을 바꾸는 작업을 합니다. 해당 파일에 대해 일반 사용자(User 그룹)도 쓰기 권한을 가지도록 퍼미션을 바꾼다고 생각해보자는 거죠. 

여기서 만약 일반 사용자가 디렉토리의 파일 생성과 삭제 권한을 가진다면, 권한 상승 취약점으로 발전시킬 수 있습니다. 하드링크를 통해서 말이죠. 

시스템프로세스가 파일의 퍼미션을 변경하기 직전에, 일반사용자가 해당 파일을 삭제하는 동시에 동일한 이름의 하드링크(타겟 예: System32\kernel32.dll)를 만들게 되면 어떻게 될까요?

시스템프로세스는 하드링크에 대해 퍼미션 변경작업을 수행하게 될 것이고, 결국 일반 사용자가 쓰기 접근이 불가능했던 파일(에:kernel32.dll)에 대해 쓰기 권한을 획득할 수 있게 됩니다.

### CVE-

실제 권한상승 익스플로잇을 통해 하드링크가 어떻게 활용되는지를 살펴보겠습니다.

살펴볼 취약점은 sandboxescaper라는 리서쳐가 작년말에 공개한 스케쥴러 서비스 권한상승(EoP) 취약점입니다. 

일반적으로 취약점을 발견하면 벤더사에 리포트를 하고, 패치 작업이 이루어진 다음에 관련 내용을 공개하는 수순을 가지는데 sandboxescaper는 fully 동작가능한 수준의 제로데이 코드를 깃허브에 공개하면서 많은 이슈가 되었습니다. 공개된 익스플로잇 코드는 몇몇 APT 그룹에서 오퍼레이션에 활용했을 정도로 활용가치(?)가 꽤 높습니다.


하드링크를 활용하는 좋은(?) 예 중 하나입니다.

취약점은 스케쥴러 서비스에 존재합니다.

스케쥴러 서비스는 ALPC포트라는 일종의 IPC를 통해 일반프로세스도 스케쥴링 서비스를 이용할 수 있도록 외부 인터페이스를 열어두었습니다. 이 중에서 SchedRPC 기능이 있었는데, 해당 기능은 `C:\Windows\Temp` 디렉토리에 있는 파일의 퍼미션을 조작할 수 있도록 해줍니다. 

해당 Temp디렉토리는 일반유저도 쓰기 가능한 디렉토리입니다. 

따라서 앞서 좋은 조건을 갖추고 있습니다.

* 하드링크를 생성한다.
  * C:\Windows\Temp\Test.dll -> C:\Printer\print.dll
* 스케쥴러 서비스를 호출한다.
    * print.dll 의 DACL을 변경합니다. (일반 사용자도 쓰기 가능하도록)
* 이때부터 print.dll의 내용은 일반유저도 변경할 수 있습니다.
    * print.dll에 나쁜(?) 코드를 심어둡니다.
* 스풀러 프로세스를 호출하여 print.dll 을 물고 올라가도록 합니다.
* 스풀러 프로세스 컨텍스트에서 해당 코드가 실행되며 권한상승이 이루어집니다.


### 

특히 파일의 퍼미션을 수정해야 할 필요성이 있는 안티바이러스나 업데이트 프로그램 등에서 해당 유형의 취약점이 있을 가능성이 높습니다.

### 대처 방안

앞서 언급한 하드링크를 통한 권한상승 취약점 유형은 언제든지 발견될 수 있습니다. 

취약점 대처 방안으로 익스플로잇이 발견될 때마다 그것에 맞춰 대응하는 방법(패턴매칭)이 대부분의 AV업체 등에서 

이러한 방법은 제로데이 익스플로잇에 대해서는 탐지율이 낮다는 단점이 있습니다.

저희 디펜스에서 출시 예정인 X-DIFFENSE에서는 하드링크를 오용하기 위해선 일반적인 CreateHardLink를 이용하는 것이 아니라, JF가 제안한 방식을 이용해야 한다는 점에 착안하여, JF 방식을 이용하면 이를 차단하는 방식을 채택했습니다. (CreateHardLink 표준 API를 사용하지 않고 다른 방법으로 하드링크를 생성한다는 것은 분명 abnormal한 behavior라고 볼 수 있습니다.)

이런 방식을 적용하면, 하드링크를 활용하여 권한상승을 시도하는 (알려지지 않은 제로데이까지 포함한)해킹공격을 효과적으로 방어할 수 있습니다.

하드링크를 쓸 경우가 많지 않은데 하물며 CreateHardLink 표준을 사용하지 않는다면 굉장히 흔치 않은 행위라고 판단하는 겁니다. 거의 JF 방식은 일반(정상적인) 프로세스가 사용하는 경우가 거의 없습니다.

X-DIFFENSE는 커널레벨(파일시스템필터)에서 하드링크 생성 과정을 감시하고 차단합니다. 

* 하드링크의 오용을 방지하는 방안




[^1]: https://googleprojectzero.blogspot.com/2015/12/between-rock-and-hard-link.html

[^2]: https://github.com/googleprojectzero/symboliclink-testing-tools/blob/master/CommonUtils/Hardlink.cpp#L20













